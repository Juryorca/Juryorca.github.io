<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="py"><meta name="copyright" content="py"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>Bomb_LAB实验报告 | 我是py</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon/favicon.ico"><link rel="mask-icon" href="/favicon/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"juryorca.github.io","root":"/","title":"宇宙终极无敌猫猫虫大王","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Bomb LAB实验报告目录[TOC] 前置准备tar -xvf bomb.tar 解压   objdump -d -M intel bomb  &gt;bomb.s   通过总体观察 可以看出主要需要理解的是phase函数 phase_defused 是共用的 ，猜测应该是成功时一些输出，先不管。    另外在gdb中 也可以使用disass phase_?查看反汇编，可以不用来回切换屏幕。">
<meta property="og:type" content="article">
<meta property="og:title" content="Bomb_LAB实验报告">
<meta property="og:url" content="http://juryorca.github.io/2025/10/16/bomblab/index.html">
<meta property="og:site_name" content="我是py">
<meta property="og:description" content="Bomb LAB实验报告目录[TOC] 前置准备tar -xvf bomb.tar 解压   objdump -d -M intel bomb  &gt;bomb.s   通过总体观察 可以看出主要需要理解的是phase函数 phase_defused 是共用的 ，猜测应该是成功时一些输出，先不管。    另外在gdb中 也可以使用disass phase_?查看反汇编，可以不用来回切换屏幕。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-16T06:56:00.000Z">
<meta property="article:modified_time" content="2025-10-16T06:57:27.514Z">
<meta property="article:author" content="py">
<meta property="article:tag" content="ics">
<meta name="twitter:card" content="summary"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="py"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="py"></a><div class="site-author-name"><a href="/about/">py</a></div><span class="site-name">我是py</span><sub class="site-subtitle">我是py</sub><div class="site-description">无敌奶龙大王cfy & cgxy和无敌疾旋鼬大王dcm</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Juryorca" title="GitHub" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/i-wanna-41-50" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="都是大佬stO" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bomb-LAB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">Bomb LAB实验报告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="toc-number">3.</span> <span class="toc-text">前置准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-1"><span class="toc-number">4.</span> <span class="toc-text">phase_1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-number">4.1.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome"><span class="toc-number">4.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-2"><span class="toc-number">5.</span> <span class="toc-text">phase_2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-1"><span class="toc-number">5.1.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome-1"><span class="toc-number">5.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-3"><span class="toc-number">6.</span> <span class="toc-text">phase_3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-2"><span class="toc-number">6.1.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome-2"><span class="toc-number">6.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-4"><span class="toc-number">7.</span> <span class="toc-text">phase_4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-3"><span class="toc-number">7.1.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome-3"><span class="toc-number">7.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-5"><span class="toc-number">8.</span> <span class="toc-text">phase_5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-4"><span class="toc-number">8.1.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome-4"><span class="toc-number">8.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phase-6"><span class="toc-number">9.</span> <span class="toc-text">phase_6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-5"><span class="toc-number">9.1.</span> <span class="toc-text">process</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-number">9.1.2.</span> <span class="toc-text">第二部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-number">9.1.3.</span> <span class="toc-text">第三部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86"><span class="toc-number">9.1.4.</span> <span class="toc-text">第四部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outcome-5"><span class="toc-number">9.2.</span> <span class="toc-text">outcome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">10.</span> <span class="toc-text">验证</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://Juryorca.github.io/2025/10/16/bomblab/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="py"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我是py"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Bomb_LAB实验报告</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2025-10-16 14:56:00" itemprop="dateCreated datePublished" datetime="2025-10-16T14:56:00+08:00">2025-10-16</time></div><div class="post-classify"><span class="post-tag"><a class="tag-item" href="/tags/ics/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">ics</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="Bomb-LAB实验报告"><a href="#Bomb-LAB实验报告" class="headerlink" title="Bomb LAB实验报告"></a>Bomb LAB实验报告</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>tar -xvf bomb.tar 解压  </p>
<p>objdump -d -M intel bomb  &gt;bomb.s  </p>
<p>通过总体观察 可以看出主要需要理解的是phase函数 phase_defused 是共用的 ，猜测应该是成功时一些输出，先不管。   </p>
<p>另外在gdb中 也可以使用disass phase_?查看反汇编，可以不用来回切换屏幕。  </p>
<p>程序开启了PIE保护 但是gdb调试时。默认是关闭aslr的。这使得调试的时候可以简单的加上一个基地址来下断点，另外可以用phase_1 + offset 这样相对取值的方式下断点。</p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x00005555555555a7 &lt;+0&gt;:     endbr64</span><br><span class="line">   0x00005555555555ab &lt;+4&gt;:     sub    rsp,0x8</span><br><span class="line">   0x00005555555555af &lt;+8&gt;:     lea    rsi,[rip+0x1b9a]        # 0x555555557150</span><br><span class="line">   0x00005555555555b6 &lt;+15&gt;:    call   0x555555555a9f &lt;strings_not_equal&gt;</span><br><span class="line">   0x00005555555555bb &lt;+20&gt;:    test   eax,eax</span><br><span class="line">   0x00005555555555bd &lt;+22&gt;:    jne    0x5555555555c4 &lt;phase_1+29&gt;</span><br><span class="line">   0x00005555555555bf &lt;+24&gt;:    add    rsp,0x8</span><br><span class="line">   0x00005555555555c3 &lt;+28&gt;:    ret</span><br><span class="line">   0x00005555555555c4 &lt;+29&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555555c9 &lt;+34&gt;:    jmp    0x5555555555bf &lt;phase_1+24&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>[rip+0x1b9a]是常用的加载某个数据的方式，从后面strings_not_equal可以看出很显然是在比较字符串，那么就需要知道rdi是什么，很显然rdi应该是在main里就传入的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555554a0 &lt;+87&gt;:    call   0x555555555c24 &lt;read_line&gt;</span><br><span class="line">0x00005555555554a5 &lt;+92&gt;:    mov    rdi,rax</span><br><span class="line">0x00005555555554a8 &lt;+95&gt;:    call   0x5555555555a7 &lt;phase_1&gt;</span><br><span class="line">0x00005555555554ad &lt;+100&gt;:   call   0x555555555d6c &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>



<p>后面的rdi也基本是这种形式 所以不用重复判断了</p>
<p>那么只需要用gdb 的 x&#x2F;s指令读取字符串内容，复制了之后重新输入就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/s 0x555555557150</span><br><span class="line">0x555555557150: &quot;For NASA, space is still a high priority.&quot;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>pwndbg是我平时一直在用的gdb，相比正常的只是多了一些废话，并不会很轮椅，所以我也就懒得调gdb配置文件了。</p>
</blockquote>
<h3 id="outcome"><a href="#outcome" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">For NASA, space is still a high priority.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure>



<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">   0x00005555555555cb &lt;+0&gt;:     endbr64</span><br><span class="line">   0x00005555555555cf &lt;+4&gt;:     push   rbp</span><br><span class="line">   0x00005555555555d0 &lt;+5&gt;:     push   rbx</span><br><span class="line">   0x00005555555555d1 &lt;+6&gt;:     sub    rsp,0x28</span><br><span class="line">   0x00005555555555d5 &lt;+10&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555555de &lt;+19&gt;:    mov    QWORD PTR [rsp+0x18],rax</span><br><span class="line">   0x00005555555555e3 &lt;+24&gt;:    xor    eax,eax</span><br><span class="line">   0x00005555555555e5 &lt;+26&gt;:    mov    rsi,rsp</span><br><span class="line">   0x00005555555555e8 &lt;+29&gt;:    call   0x555555555bdf &lt;read_six_numbers&gt;</span><br><span class="line">   0x00005555555555ed &lt;+34&gt;:    cmp    DWORD PTR [rsp],0x0</span><br><span class="line">   0x00005555555555f1 &lt;+38&gt;:    js     0x5555555555fd &lt;phase_2+50&gt;</span><br><span class="line">   0x00005555555555f3 &lt;+40&gt;:    mov    rbp,rsp</span><br><span class="line">   0x00005555555555f6 &lt;+43&gt;:    mov    ebx,0x1</span><br><span class="line">   0x00005555555555fb &lt;+48&gt;:    jmp    0x555555555615 &lt;phase_2+74&gt;</span><br><span class="line">   0x00005555555555fd &lt;+50&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555602 &lt;+55&gt;:    jmp    0x5555555555f3 &lt;phase_2+40&gt;</span><br><span class="line">   0x0000555555555604 &lt;+57&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555609 &lt;+62&gt;:    add    ebx,0x1</span><br><span class="line">   0x000055555555560c &lt;+65&gt;:    add    rbp,0x4</span><br><span class="line">   0x0000555555555610 &lt;+69&gt;:    cmp    ebx,0x6</span><br><span class="line">   0x0000555555555613 &lt;+72&gt;:    je     0x555555555621 &lt;phase_2+86&gt;</span><br><span class="line">   0x0000555555555615 &lt;+74&gt;:    mov    eax,ebx</span><br><span class="line">   0x0000555555555617 &lt;+76&gt;:    add    eax,DWORD PTR [rbp+0x0]</span><br><span class="line">   0x000055555555561a &lt;+79&gt;:    cmp    DWORD PTR [rbp+0x4],eax</span><br><span class="line">   0x000055555555561d &lt;+82&gt;:    je     0x555555555609 &lt;phase_2+62&gt;</span><br><span class="line">   0x000055555555561f &lt;+84&gt;:    jmp    0x555555555604 &lt;phase_2+57&gt;</span><br><span class="line">   0x0000555555555621 &lt;+86&gt;:    mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x0000555555555626 &lt;+91&gt;:    xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000055555555562f &lt;+100&gt;:   jne    0x555555555638 &lt;phase_2+109&gt;</span><br><span class="line">   0x0000555555555631 &lt;+102&gt;:   add    rsp,0x28</span><br><span class="line">   0x0000555555555635 &lt;+106&gt;:   pop    rbx</span><br><span class="line">   0x0000555555555636 &lt;+107&gt;:   pop    rbp</span><br><span class="line">   0x0000555555555637 &lt;+108&gt;:   ret</span><br><span class="line">   0x0000555555555638 &lt;+109&gt;:   call   0x555555555220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>



<h3 id="process-1"><a href="#process-1" class="headerlink" title="process"></a>process</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555555d1 &lt;+6&gt;:     sub    rsp,0x28</span><br><span class="line">0x00005555555555d5 &lt;+10&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x00005555555555de &lt;+19&gt;:    mov    QWORD PTR [rsp+0x18],rax</span><br></pre></td></tr></table></figure>



<p>这可能在不熟悉canary保护的人看起来会觉得有点诡异。  </p>
<p>这其实是canary保护的一个固定的形式，加载fs段里的随机值到栈rbp上方 ,函数退出时进行比较，和我现在要做的部分无关。  </p>
<blockquote>
<p>Q:为什么phase_1 没有这个保护？A:phase_1根本没用到栈。</p>
</blockquote>
<p>具体关注开启栈帧和关闭栈帧中间的部分  </p>
<p>read_six_numbers 可以猜测大概率是将rdi字符串拆成六个数值，然后存入rsi 。 rsi指向栈顶，这是栈上数组的表现。 </p>
<p>这里可以具体看看read_six_numbers怎么实现的，但是我觉得不如猜测用空格隔开更方便。  </p>
<p>后面取值用了大量的DWORD PTR 可以直接假设是int 类型的数组。下面记这个数组为 int buf[6]  </p>
<p>js貌似不是一个很常见的指令,在这里它比较 buf[0] 与 0 ,如果buf[0]&lt;0 则会跳转。这里不能跳转。  </p>
<p>可以令buf[0] &#x3D; 0  </p>
<p>mov rbp,rsp 这里比较反常理，一般rbp是不会被使用到的，这里就当是被使用了。 </p>
<p>+40 到 +84 是一个循环，但是确实有点杂乱 </p>
<p>ebx 很显然就是数组下标，从 1-5 到5时退出循环。 </p>
<p>那么后面的操作就是在把i + buf[i-1] 判断是否等于buf [i] </p>
<p>综上 buf 的一个解可以是buf [6]&#x3D; {0,1,3,6,10,15}  </p>
<h3 id="outcome-1"><a href="#outcome-1" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">0 1 3 6 10 15</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br></pre></td></tr></table></figure>





<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">   0x000055555555563d &lt;+0&gt;:     endbr64</span><br><span class="line">   0x0000555555555641 &lt;+4&gt;:     sub    rsp,0x18</span><br><span class="line">   0x0000555555555645 &lt;+8&gt;:     mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000055555555564e &lt;+17&gt;:    mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x0000555555555653 &lt;+22&gt;:    xor    eax,eax</span><br><span class="line">   0x0000555555555655 &lt;+24&gt;:    lea    rcx,[rsp+0x4]</span><br><span class="line">   0x000055555555565a &lt;+29&gt;:    mov    rdx,rsp</span><br><span class="line">   0x000055555555565d &lt;+32&gt;:    lea    rsi,[rip+0x1ccb]        # 0x55555555732f</span><br><span class="line">   0x0000555555555664 &lt;+39&gt;:    call   0x5555555552c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000555555555669 &lt;+44&gt;:    cmp    eax,0x1</span><br><span class="line">   0x000055555555566c &lt;+47&gt;:    jle    0x55555555568c &lt;phase_3+79&gt;</span><br><span class="line">   0x000055555555566e &lt;+49&gt;:    cmp    DWORD PTR [rsp],0x7</span><br><span class="line">   0x0000555555555672 &lt;+53&gt;:    ja     0x555555555712 &lt;phase_3+213&gt;</span><br><span class="line">   0x0000555555555678 &lt;+59&gt;:    mov    eax,DWORD PTR [rsp]</span><br><span class="line">   0x000055555555567b &lt;+62&gt;:    lea    rdx,[rip+0x1b3e]        # 0x5555555571c0</span><br><span class="line">   0x0000555555555682 &lt;+69&gt;:    movsxd rax,DWORD PTR [rdx+rax*4]</span><br><span class="line">   0x0000555555555686 &lt;+73&gt;:    add    rax,rdx</span><br><span class="line">   0x0000555555555689 &lt;+76&gt;:    notrack jmp rax</span><br><span class="line">   0x000055555555568c &lt;+79&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555691 &lt;+84&gt;:    jmp    0x55555555566e &lt;phase_3+49&gt;</span><br><span class="line">   0x0000555555555693 &lt;+86&gt;:    mov    eax,0x33e</span><br><span class="line">   0x0000555555555698 &lt;+91&gt;:    sub    eax,0x152</span><br><span class="line">   0x000055555555569d &lt;+96&gt;:    add    eax,0x179</span><br><span class="line">   0x00005555555556a2 &lt;+101&gt;:   sub    eax,0xcc</span><br><span class="line">   0x00005555555556a7 &lt;+106&gt;:   add    eax,0xcc</span><br><span class="line">   0x00005555555556ac &lt;+111&gt;:   sub    eax,0xcc</span><br><span class="line">   0x00005555555556b1 &lt;+116&gt;:   add    eax,0xcc</span><br><span class="line">   0x00005555555556b6 &lt;+121&gt;:   sub    eax,0xcc</span><br><span class="line">   0x00005555555556bb &lt;+126&gt;:   cmp    DWORD PTR [rsp],0x5</span><br><span class="line">   0x00005555555556bf &lt;+130&gt;:   jg     0x5555555556c7 &lt;phase_3+138&gt;</span><br><span class="line">   0x00005555555556c1 &lt;+132&gt;:   cmp    DWORD PTR [rsp+0x4],eax</span><br><span class="line">   0x00005555555556c5 &lt;+136&gt;:   je     0x5555555556cc &lt;phase_3+143&gt;</span><br><span class="line">   0x00005555555556c7 &lt;+138&gt;:   call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555556cc &lt;+143&gt;:   mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x00005555555556d1 &lt;+148&gt;:   xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555556da &lt;+157&gt;:   jne    0x55555555571e &lt;phase_3+225&gt;</span><br><span class="line">   0x00005555555556dc &lt;+159&gt;:   add    rsp,0x18</span><br><span class="line">   0x00005555555556e0 &lt;+163&gt;:   ret</span><br><span class="line">   0x00005555555556e1 &lt;+164&gt;:   mov    eax,0x0</span><br><span class="line">   0x00005555555556e6 &lt;+169&gt;:   jmp    0x555555555698 &lt;phase_3+91&gt;</span><br><span class="line">   0x00005555555556e8 &lt;+171&gt;:   mov    eax,0x0</span><br><span class="line">   0x00005555555556ed &lt;+176&gt;:   jmp    0x55555555569d &lt;phase_3+96&gt;</span><br><span class="line">   0x00005555555556ef &lt;+178&gt;:   mov    eax,0x0</span><br><span class="line">   0x00005555555556f4 &lt;+183&gt;:   jmp    0x5555555556a2 &lt;phase_3+101&gt;</span><br><span class="line">   0x00005555555556f6 &lt;+185&gt;:   mov    eax,0x0</span><br><span class="line">   0x00005555555556fb &lt;+190&gt;:   jmp    0x5555555556a7 &lt;phase_3+106&gt;</span><br><span class="line">   0x00005555555556fd &lt;+192&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000555555555702 &lt;+197&gt;:   jmp    0x5555555556ac &lt;phase_3+111&gt;</span><br><span class="line">   0x0000555555555704 &lt;+199&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000555555555709 &lt;+204&gt;:   jmp    0x5555555556b1 &lt;phase_3+116&gt;</span><br><span class="line">   0x000055555555570b &lt;+206&gt;:   mov    eax,0x0</span><br><span class="line">   0x0000555555555710 &lt;+211&gt;:   jmp    0x5555555556b6 &lt;phase_3+121&gt;</span><br><span class="line">   0x0000555555555712 &lt;+213&gt;:   call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555717 &lt;+218&gt;:   mov    eax,0x0</span><br><span class="line">   0x000055555555571c &lt;+223&gt;:   jmp    0x5555555556bb &lt;phase_3+126&gt;</span><br><span class="line">   0x000055555555571e &lt;+225&gt;:   call   0x555555555220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h3 id="process-2"><a href="#process-2" class="headerlink" title="process"></a>process</h3><p>更加复杂！ </p>
<p>首先调用了一个sscanf 。 </p>
<p>这个函数和scanf差别就是,它读取数据是在第一个参数指向的位置 </p>
<p>rdi仍然是readline传入的。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555655 &lt;+24&gt;:    lea    rcx,[rsp+0x4]</span><br><span class="line">0x000055555555565a &lt;+29&gt;:    mov    rdx,rsp</span><br></pre></td></tr></table></figure>



<p>这两步就是给出了”%d %d” 需要存储到的位置，第一个放到[rsp] 第二个放到[rsp+4]  </p>
<p>cmp eax,0x1 后面是对于scanf一个检查 正常读取就可以不看  </p>
<p>cmp DWORD PTR [rsp],0x7 要求第一个参数小于等于7</p>
<p>然后又来了个复杂的玩意! </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555678 &lt;+59&gt;:    mov    eax,DWORD PTR [rsp]</span><br><span class="line"> 0x000055555555567b &lt;+62&gt;:    lea    rdx,[rip+0x1b3e]        # 0x5555555571c0</span><br><span class="line"> 0x0000555555555682 &lt;+69&gt;:    movsxd rax,DWORD PTR [rdx+rax*4]</span><br><span class="line"> 0x0000555555555686 &lt;+73&gt;:    add    rax,rdx</span><br><span class="line"> 0x0000555555555689 &lt;+76&gt;:    notrack jmp rax</span><br></pre></td></tr></table></figure>



<p>一通瞪眼法之后，我认为这个很像一个跳转表，rdx加载了</p>
<p>  0x5555555571c0 ,  0x5555555571c 后面存储了一系列相对偏移，然后加上这个相对偏移后，进行跳转。</p>
<p>那么[rsp]就是相对偏移的数组下标。那么就需要计算好这个switch! 可以先假设switch都是跳转到函数内的。这样就可以不盲目的计算，先看后面的逻辑。</p>
<p>发现在ret指令后面存了一堆jmp,很显然这不是正常的,可以直接假设跳转表就是跳到这里 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555556bb &lt;+126&gt;:   cmp    DWORD PTR [rsp],0x5</span><br><span class="line">0x00005555555556bf &lt;+130&gt;:   jg     0x5555555556c7 &lt;phase_3+138&gt;</span><br><span class="line">0x00005555555556c1 &lt;+132&gt;:   cmp    DWORD PTR [rsp+0x4],eax</span><br></pre></td></tr></table></figure>



<p>这三个指令显然就是最终的目标! </p>
<p>[rsp]&gt;&#x3D;5 时，直接bomb，直接假设[rsp]等于5,第二个参数就是运行的结果。</p>
<p>可以直接输入一个5，用gdb查看最后的rax，这样就跳过了繁琐的计算过程</p>
<p>下好断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$eax</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = -204</span></span><br></pre></td></tr></table></figure>



<p>然后重新运行一遍程序</p>
<p>输入5 -204</p>
<h3 id="outcome-2"><a href="#outcome-2" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">Halfway there!</span><br></pre></td></tr></table></figure>



<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x0000555555555764 &lt;+0&gt;:     endbr64</span><br><span class="line">   0x0000555555555768 &lt;+4&gt;:     sub    rsp,0x18</span><br><span class="line">   0x000055555555576c &lt;+8&gt;:     mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555555775 &lt;+17&gt;:    mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x000055555555577a &lt;+22&gt;:    xor    eax,eax</span><br><span class="line">   0x000055555555577c &lt;+24&gt;:    lea    rcx,[rsp+0x4]</span><br><span class="line">   0x0000555555555781 &lt;+29&gt;:    mov    rdx,rsp</span><br><span class="line">   0x0000555555555784 &lt;+32&gt;:    lea    rsi,[rip+0x1ba4]        # 0x55555555732f</span><br><span class="line">   0x000055555555578b &lt;+39&gt;:    call   0x5555555552c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000555555555790 &lt;+44&gt;:    cmp    eax,0x2</span><br><span class="line">   0x0000555555555793 &lt;+47&gt;:    jne    0x55555555579b &lt;phase_4+55&gt;</span><br><span class="line">   0x0000555555555795 &lt;+49&gt;:    cmp    DWORD PTR [rsp],0xe</span><br><span class="line">   0x0000555555555799 &lt;+53&gt;:    jbe    0x5555555557a0 &lt;phase_4+60&gt;</span><br><span class="line">   0x000055555555579b &lt;+55&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555557a0 &lt;+60&gt;:    mov    edx,0xe</span><br><span class="line">   0x00005555555557a5 &lt;+65&gt;:    mov    esi,0x0</span><br><span class="line">   0x00005555555557aa &lt;+70&gt;:    mov    edi,DWORD PTR [rsp]</span><br><span class="line">   0x00005555555557ad &lt;+73&gt;:    call   0x555555555723 &lt;func4&gt;</span><br><span class="line">   0x00005555555557b2 &lt;+78&gt;:    cmp    eax,0x7</span><br><span class="line">   0x00005555555557b5 &lt;+81&gt;:    jne    0x5555555557be &lt;phase_4+90&gt;</span><br><span class="line">   0x00005555555557b7 &lt;+83&gt;:    cmp    DWORD PTR [rsp+0x4],0x7</span><br><span class="line">   0x00005555555557bc &lt;+88&gt;:    je     0x5555555557c3 &lt;phase_4+95&gt;</span><br><span class="line">   0x00005555555557be &lt;+90&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555557c3 &lt;+95&gt;:    mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x00005555555557c8 &lt;+100&gt;:   xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555557d1 &lt;+109&gt;:   jne    0x5555555557d8 &lt;phase_4+116&gt;</span><br><span class="line">   0x00005555555557d3 &lt;+111&gt;:   add    rsp,0x18</span><br><span class="line">   0x00005555555557d7 &lt;+115&gt;:   ret</span><br><span class="line">   0x00005555555557d8 &lt;+116&gt;:   call   0x555555555220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>



<h3 id="process-3"><a href="#process-3" class="headerlink" title="process"></a>process</h3><p>突然代码量就变少了!</p>
<p>还是和刚才一样 输入两个数字到[rsp] [rsp+4]</p>
<p>要求[rsp]&lt;&#x3D;15</p>
<p>然后跳到func4,要求其返回值等于7。可以先看外面的逻辑，再看func4具体干了什么</p>
<p>[rsp+4]只是单纯的要求等于7 ，为什么不只读入一个参数呢?</p>
<p>进入func4:</p>
<p>rdi &#x3D; [rsp] rsi &#x3D; 0 rdx &#x3D; 0xe</p>
<p>可以看出这完全是一个递归!</p>
<p>先尝试直接让他跳出有没有解，但是直接跳出显然就不会等于7。</p>
<p>那只能尝试去翻译这个函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">func4(x,y,z)&#123;</span><br><span class="line">    <span class="type">int</span> temp = z-y ;</span><br><span class="line">    <span class="type">int</span> flag = (<span class="type">unsigned</span>)temp &gt;&gt; <span class="number">31</span> ;</span><br><span class="line">    temp+=flag;</span><br><span class="line">    temp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    temp+=y;</span><br><span class="line">    <span class="keyword">if</span> (temp&lt;=x)&#123;</span><br><span class="line">         <span class="keyword">if</span> (temp == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            y = temp+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*func4(x,y,z) + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            z= temp <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*func4(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>前面那个部分的计算还是不像人类能理解的，于是我优化了一下。</p>
<p>经过一堆判断 我认为这个算法实际上执行了x+y &#x2F; 2 。但是简单粗暴的相加&#x2F;2 可能会有溢出。另外在负数时，需要向零截断，所以加上了一个flag。</p>
<p>那么就可以简化为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">func4(x,y,z)&#123;</span><br><span class="line">    <span class="type">int</span> temp = (y+z)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp==x) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;x) <span class="keyword">return</span>  <span class="number">2</span>*func4(x,temp+<span class="number">1</span>,z) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp&gt;x) <span class="keyword">return</span>  <span class="number">2</span>*func4(x,y,temp<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行func(x,0,15),x是输入值。</p>
<p>通过逆推。函数最终节点的返回值必然是0 , 需要构造出0  1  3  7这样的返回流程</p>
<p>也就是执行四次后,让temp等于x</p>
<p>1:7,2:11,3:13,4:14 输入14尝试一下!</p>
<h3 id="outcome-3"><a href="#outcome-3" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">14 7</span><br><span class="line">So you got that one.  Try this one.</span><br></pre></td></tr></table></figure>



<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x00005555555557dd &lt;+0&gt;:     endbr64</span><br><span class="line">   0x00005555555557e1 &lt;+4&gt;:     push   rbx</span><br><span class="line">   0x00005555555557e2 &lt;+5&gt;:     mov    rbx,rdi</span><br><span class="line">   0x00005555555557e5 &lt;+8&gt;:     call   0x555555555a7e &lt;string_length&gt;</span><br><span class="line">   0x00005555555557ea &lt;+13&gt;:    cmp    eax,0x6</span><br><span class="line">   0x00005555555557ed &lt;+16&gt;:    jne    0x55555555581b &lt;phase_5+62&gt;</span><br><span class="line">   0x00005555555557ef &lt;+18&gt;:    mov    rax,rbx</span><br><span class="line">   0x00005555555557f2 &lt;+21&gt;:    lea    rdi,[rbx+0x6]</span><br><span class="line">   0x00005555555557f6 &lt;+25&gt;:    mov    ecx,0x0</span><br><span class="line">   0x00005555555557fb &lt;+30&gt;:    lea    rsi,[rip+0x19de]        # 0x5555555571e0 &lt;array.3471&gt;</span><br><span class="line">   0x0000555555555802 &lt;+37&gt;:    movzx  edx,BYTE PTR [rax]</span><br><span class="line">   0x0000555555555805 &lt;+40&gt;:    and    edx,0xf</span><br><span class="line">   0x0000555555555808 &lt;+43&gt;:    add    ecx,DWORD PTR [rsi+rdx*4]</span><br><span class="line">   0x000055555555580b &lt;+46&gt;:    add    rax,0x1</span><br><span class="line">   0x000055555555580f &lt;+50&gt;:    cmp    rax,rdi</span><br><span class="line">   0x0000555555555812 &lt;+53&gt;:    jne    0x555555555802 &lt;phase_5+37&gt;</span><br><span class="line">   0x0000555555555814 &lt;+55&gt;:    cmp    ecx,0x3e</span><br><span class="line">   0x0000555555555817 &lt;+58&gt;:    jne    0x555555555822 &lt;phase_5+69&gt;</span><br><span class="line">   0x0000555555555819 &lt;+60&gt;:    pop    rbx</span><br><span class="line">   0x000055555555581a &lt;+61&gt;:    ret</span><br><span class="line">   0x000055555555581b &lt;+62&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555820 &lt;+67&gt;:    jmp    0x5555555557ef &lt;phase_5+18&gt;</span><br><span class="line">   0x0000555555555822 &lt;+69&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555827 &lt;+74&gt;:    jmp    0x555555555819 &lt;phase_5+60&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h3 id="process-4"><a href="#process-4" class="headerlink" title="process"></a>process</h3><p>循环还是比递归看着舒服。</p>
<p>涉及到了两个数组</p>
<p>一个是char input[7]; 一个是 int array[16]</p>
<p>先是检查了字符串长度是否为6。</p>
<p>然后根据input[7]里每个char的值，用0xf取掩码(相当于%16) ,当作array数组下标，进行取值。</p>
<p>最终要使得取出来的值相加等于0x3e</p>
<p>使用x&#x2F;16wx   0x5555555571e0 可以方便的列出这个数组的内容。</p>
<blockquote>
<p>事实上可以规定数据类型 然后用print 但是这太麻烦了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5555555571e0 &lt;array.3471&gt;:    0x00000002      0x0000000a      0x00000006      0x00000001</span><br><span class="line">0x5555555571f0 &lt;array.3471+16&gt;: 0x0000000c      0x00000010      0x00000009      0x00000003</span><br><span class="line">0x555555557200 &lt;array.3471+32&gt;: 0x00000004      0x00000007      0x0000000e      0x00000005</span><br><span class="line">0x555555557210 &lt;array.3471+48&gt;: 0x0000000b      0x00000008      0x0000000f      0x0000000d</span><br></pre></td></tr></table></figure>



<p>随便取几个6起来为0x3e就行了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p 0x3e-0xf-0xd-0x8-0xb-0x5-0xa</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = 0</span></span><br></pre></td></tr></table></figure>

<p>对应数组下标 1 11 12-15</p>
<p>可以取大写英文字母 AKLMNO</p>
<h3 id="outcome-4"><a href="#outcome-4" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">AKLMNO</span><br><span class="line">Good work!  On to the next...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555829 &lt;+0&gt;:     endbr64</span><br><span class="line">0x000055555555582d &lt;+4&gt;:     push   r14</span><br><span class="line">0x000055555555582f &lt;+6&gt;:     push   r13</span><br><span class="line">0x0000555555555831 &lt;+8&gt;:     push   r12</span><br><span class="line">0x0000555555555833 &lt;+10&gt;:    push   rbp</span><br><span class="line">0x0000555555555834 &lt;+11&gt;:    push   rbx</span><br><span class="line">0x0000555555555835 &lt;+12&gt;:    sub    rsp,0x60</span><br><span class="line">0x0000555555555839 &lt;+16&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x0000555555555842 &lt;+25&gt;:    mov    QWORD PTR [rsp+0x58],rax</span><br><span class="line">0x0000555555555847 &lt;+30&gt;:    xor    eax,eax</span><br><span class="line">0x0000555555555849 &lt;+32&gt;:    mov    r13,rsp</span><br><span class="line">0x000055555555584c &lt;+35&gt;:    mov    rsi,r13</span><br><span class="line">0x000055555555584f &lt;+38&gt;:    call   0x555555555bdf &lt;read_six_numbers&gt;</span><br><span class="line">0x0000555555555854 &lt;+43&gt;:    mov    r14d,0x1</span><br><span class="line">0x000055555555585a &lt;+49&gt;:    mov    r12,rsp</span><br><span class="line">0x000055555555585d &lt;+52&gt;:    jmp    0x555555555887 &lt;phase_6+94&gt;</span><br><span class="line">0x000055555555585f &lt;+54&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555864 &lt;+59&gt;:    jmp    0x555555555896 &lt;phase_6+109&gt;</span><br><span class="line">0x0000555555555866 &lt;+61&gt;:    add    rbx,0x1</span><br><span class="line">0x000055555555586a &lt;+65&gt;:    cmp    ebx,0x5</span><br><span class="line">0x000055555555586d &lt;+68&gt;:    jg     0x55555555587f &lt;phase_6+86&gt;</span><br><span class="line">0x000055555555586f &lt;+70&gt;:    mov    eax,DWORD PTR [r12+rbx*4]</span><br><span class="line">0x0000555555555873 &lt;+74&gt;:    cmp    DWORD PTR [rbp+0x0],eax</span><br><span class="line">0x0000555555555876 &lt;+77&gt;:    jne    0x555555555866 &lt;phase_6+61&gt;</span><br><span class="line">0x0000555555555878 &lt;+79&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555587d &lt;+84&gt;:    jmp    0x555555555866 &lt;phase_6+61&gt;</span><br><span class="line">0x000055555555587f &lt;+86&gt;:    add    r14,0x1</span><br><span class="line">0x0000555555555883 &lt;+90&gt;:    add    r13,0x4</span><br><span class="line">0x0000555555555887 &lt;+94&gt;:    mov    rbp,r13</span><br><span class="line">0x000055555555588a &lt;+97&gt;:    mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">0x000055555555588e &lt;+101&gt;:   sub    eax,0x1</span><br><span class="line">0x0000555555555891 &lt;+104&gt;:   cmp    eax,0x5</span><br><span class="line">0x0000555555555894 &lt;+107&gt;:   ja     0x55555555585f &lt;phase_6+54&gt;</span><br><span class="line">0x0000555555555896 &lt;+109&gt;:   cmp    r14d,0x5</span><br><span class="line">0x000055555555589a &lt;+113&gt;:   jg     0x5555555558a1 &lt;phase_6+120&gt;</span><br><span class="line">0x000055555555589c &lt;+115&gt;:   mov    rbx,r14</span><br><span class="line">0x000055555555589f &lt;+118&gt;:   jmp    0x55555555586f &lt;phase_6+70&gt;</span><br><span class="line">0x00005555555558a1 &lt;+120&gt;:   mov    esi,0x0</span><br><span class="line">0x00005555555558a6 &lt;+125&gt;:   mov    ecx,DWORD PTR [rsp+rsi*4]</span><br><span class="line">0x00005555555558a9 &lt;+128&gt;:   mov    eax,0x1</span><br><span class="line">0x00005555555558ae &lt;+133&gt;:   lea    rdx,[rip+0x395b]        # 0x555555559210 &lt;node1&gt;</span><br><span class="line">0x00005555555558b5 &lt;+140&gt;:   cmp    ecx,0x1</span><br><span class="line">0x00005555555558b8 &lt;+143&gt;:   jle    0x5555555558c5 &lt;phase_6+156&gt;</span><br><span class="line">0x00005555555558ba &lt;+145&gt;:   mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">0x00005555555558be &lt;+149&gt;:   add    eax,0x1</span><br><span class="line">0x00005555555558c1 &lt;+152&gt;:   cmp    eax,ecx</span><br><span class="line">0x00005555555558c3 &lt;+154&gt;:   jne    0x5555555558ba &lt;phase_6+145&gt;</span><br><span class="line">0x00005555555558c5 &lt;+156&gt;:   mov    QWORD PTR [rsp+rsi*8+0x20],rdx</span><br><span class="line">0x00005555555558ca &lt;+161&gt;:   add    rsi,0x1</span><br><span class="line">0x00005555555558ce &lt;+165&gt;:   cmp    rsi,0x6</span><br><span class="line">0x00005555555558d2 &lt;+169&gt;:   jne    0x5555555558a6 &lt;phase_6+125&gt;</span><br><span class="line">0x00005555555558d4 &lt;+171&gt;:   mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">0x00005555555558d9 &lt;+176&gt;:   mov    rax,QWORD PTR [rsp+0x28]</span><br><span class="line">0x00005555555558de &lt;+181&gt;:   mov    QWORD PTR [rbx+0x8],rax</span><br><span class="line">0x00005555555558e2 &lt;+185&gt;:   mov    rdx,QWORD PTR [rsp+0x30]</span><br><span class="line">0x00005555555558e7 &lt;+190&gt;:   mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">0x00005555555558eb &lt;+194&gt;:   mov    rax,QWORD PTR [rsp+0x38]</span><br><span class="line">0x00005555555558f0 &lt;+199&gt;:   mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">0x00005555555558f4 &lt;+203&gt;:   mov    rdx,QWORD PTR [rsp+0x40]</span><br><span class="line">0x00005555555558f9 &lt;+208&gt;:   mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">0x00005555555558fd &lt;+212&gt;:   mov    rax,QWORD PTR [rsp+0x48]</span><br><span class="line">0x0000555555555902 &lt;+217&gt;:   mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">0x0000555555555906 &lt;+221&gt;:   mov    QWORD PTR [rax+0x8],0x0</span><br><span class="line">0x000055555555590e &lt;+229&gt;:   mov    ebp,0x5</span><br><span class="line">0x0000555555555913 &lt;+234&gt;:   jmp    0x55555555591e &lt;phase_6+245&gt;</span><br><span class="line">0x0000555555555915 &lt;+236&gt;:   mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">0x0000555555555919 &lt;+240&gt;:   sub    ebp,0x1</span><br><span class="line">0x000055555555591c &lt;+243&gt;:   je     0x55555555592f &lt;phase_6+262&gt;</span><br><span class="line">0x000055555555591e &lt;+245&gt;:   mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">0x0000555555555922 &lt;+249&gt;:   mov    eax,DWORD PTR [rax]</span><br><span class="line">0x0000555555555924 &lt;+251&gt;:   cmp    DWORD PTR [rbx],eax</span><br><span class="line">0x0000555555555926 &lt;+253&gt;:   jle    0x555555555915 &lt;phase_6+236&gt;</span><br><span class="line">0x0000555555555928 &lt;+255&gt;:   call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555592d &lt;+260&gt;:   jmp    0x555555555915 &lt;phase_6+236&gt;</span><br><span class="line">0x000055555555592f &lt;+262&gt;:   mov    rax,QWORD PTR [rsp+0x58]</span><br><span class="line">0x0000555555555934 &lt;+267&gt;:   xor    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000055555555593d &lt;+276&gt;:   jne    0x55555555594c &lt;phase_6+291&gt;</span><br><span class="line">0x000055555555593f &lt;+278&gt;:   add    rsp,0x60</span><br><span class="line">0x0000555555555943 &lt;+282&gt;:   pop    rbx</span><br><span class="line">0x0000555555555944 &lt;+283&gt;:   pop    rbp</span><br><span class="line">0x0000555555555945 &lt;+284&gt;:   pop    r12</span><br><span class="line">0x0000555555555947 &lt;+286&gt;:   pop    r13</span><br><span class="line">0x0000555555555949 &lt;+288&gt;:   pop    r14</span><br><span class="line">0x000055555555594b &lt;+290&gt;:   ret</span><br><span class="line">0x000055555555594c &lt;+291&gt;:   call   0x555555555220 &lt;__stack_chk_fail@plt&gt; </span><br></pre></td></tr></table></figure>

<h3 id="process-5"><a href="#process-5" class="headerlink" title="process"></a>process</h3><p>略显复杂 但还好 没有递归。 </p>
<p>先大致看一下逻辑，可以分成四个部分。</p>
<h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555829 &lt;+0&gt;:     endbr64</span><br><span class="line">0x000055555555582d &lt;+4&gt;:     push   r14</span><br><span class="line">0x000055555555582f &lt;+6&gt;:     push   r13</span><br><span class="line">0x0000555555555831 &lt;+8&gt;:     push   r12</span><br><span class="line">0x0000555555555833 &lt;+10&gt;:    push   rbp</span><br><span class="line">0x0000555555555834 &lt;+11&gt;:    push   rbx</span><br><span class="line">0x0000555555555835 &lt;+12&gt;:    sub    rsp,0x60</span><br><span class="line">0x0000555555555839 &lt;+16&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x0000555555555842 &lt;+25&gt;:    mov    QWORD PTR [rsp+0x58],rax</span><br><span class="line">0x0000555555555847 &lt;+30&gt;:    xor    eax,eax</span><br><span class="line">0x0000555555555849 &lt;+32&gt;:    mov    r13,rsp</span><br><span class="line">0x000055555555584c &lt;+35&gt;:    mov    rsi,r13</span><br><span class="line">0x000055555555584f &lt;+38&gt;:    call   0x555555555bdf &lt;read_six_numbers&gt;</span><br><span class="line">0x0000555555555854 &lt;+43&gt;:    mov    r14d,0x1</span><br><span class="line">0x000055555555585a &lt;+49&gt;:    mov    r12,rsp</span><br><span class="line">0x000055555555585d &lt;+52&gt;:    jmp    0x555555555887 &lt;phase_6+94&gt;</span><br><span class="line">0x000055555555585f &lt;+54&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555864 &lt;+59&gt;:    jmp    0x555555555896 &lt;phase_6+109&gt;</span><br><span class="line">0x0000555555555866 &lt;+61&gt;:    add    rbx,0x1</span><br><span class="line">0x000055555555586a &lt;+65&gt;:    cmp    ebx,0x5</span><br><span class="line">0x000055555555586d &lt;+68&gt;:    jg     0x55555555587f &lt;phase_6+86&gt;</span><br><span class="line">0x000055555555586f &lt;+70&gt;:    mov    eax,DWORD PTR [r12+rbx*4]</span><br><span class="line">0x0000555555555873 &lt;+74&gt;:    cmp    DWORD PTR [rbp+0x0],eax</span><br><span class="line">0x0000555555555876 &lt;+77&gt;:    jne    0x555555555866 &lt;phase_6+61&gt;</span><br><span class="line">0x0000555555555878 &lt;+79&gt;:    call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555587d &lt;+84&gt;:    jmp    0x555555555866 &lt;phase_6+61&gt;</span><br><span class="line">0x000055555555587f &lt;+86&gt;:    add    r14,0x1</span><br><span class="line">0x0000555555555883 &lt;+90&gt;:    add    r13,0x4</span><br><span class="line">0x0000555555555887 &lt;+94&gt;:    mov    rbp,r13</span><br><span class="line">0x000055555555588a &lt;+97&gt;:    mov    eax,DWORD PTR [r13+0x0]</span><br><span class="line">0x000055555555588e &lt;+101&gt;:   sub    eax,0x1</span><br><span class="line">0x0000555555555891 &lt;+104&gt;:   cmp    eax,0x5</span><br><span class="line">0x0000555555555894 &lt;+107&gt;:   ja     0x55555555585f &lt;phase_6+54&gt;</span><br><span class="line">0x0000555555555896 &lt;+109&gt;:   cmp    r14d,0x5</span><br><span class="line">0x000055555555589a &lt;+113&gt;:   jg     0x5555555558a1 &lt;phase_6+120&gt;</span><br><span class="line">0x000055555555589c &lt;+115&gt;:   mov    rbx,r14</span><br><span class="line">0x000055555555589f &lt;+118&gt;:   jmp    0x55555555586f &lt;phase_6+70&gt;</span><br></pre></td></tr></table></figure>



<p>主要做了两个检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000055555555586f &lt;+70&gt;:    mov    eax,DWORD PTR [r12+rbx*4]</span><br><span class="line">0x0000555555555873 &lt;+74&gt;:    cmp    DWORD PTR [rbp+0x0],eax</span><br></pre></td></tr></table></figure>



<p>检查每相邻两个数是不是不相等的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000055555555588e &lt;+101&gt;:   sub    eax,0x1</span><br><span class="line">0x0000555555555891 &lt;+104&gt;:   cmp    eax,0x5</span><br><span class="line">0x0000555555555894 &lt;+107&gt;:   ja     0x55555555585f &lt;phase_6+54&gt;</span><br></pre></td></tr></table></figure>

<p>检查每个数-1是不是在0 到 5之间 就是要输入1到6</p>
<blockquote>
<p>对于这种循环，有个技巧，就是rbx一般是for (int i …)里的i，当然不保证一定正确，但是确实有这个规律</p>
</blockquote>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555558a1 &lt;+120&gt;:   mov    esi,0x0</span><br><span class="line">0x00005555555558a6 &lt;+125&gt;:   mov    ecx,DWORD PTR [rsp+rsi*4]</span><br><span class="line">0x00005555555558a9 &lt;+128&gt;:   mov    eax,0x1</span><br><span class="line">0x00005555555558ae &lt;+133&gt;:   lea    rdx,[rip+0x395b]        # 0x555555559210 &lt;node1&gt;</span><br><span class="line">0x00005555555558b5 &lt;+140&gt;:   cmp    ecx,0x1</span><br><span class="line">0x00005555555558b8 &lt;+143&gt;:   jle    0x5555555558c5 &lt;phase_6+156&gt;</span><br><span class="line">0x00005555555558ba &lt;+145&gt;:   mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">0x00005555555558be &lt;+149&gt;:   add    eax,0x1</span><br><span class="line">0x00005555555558c1 &lt;+152&gt;:   cmp    eax,ecx</span><br><span class="line">0x00005555555558c3 &lt;+154&gt;:   jne    0x5555555558ba &lt;phase_6+145&gt;</span><br><span class="line">0x00005555555558c5 &lt;+156&gt;:   mov    QWORD PTR [rsp+rsi*8+0x20],rdx</span><br><span class="line">0x00005555555558ca &lt;+161&gt;:   add    rsi,0x1</span><br><span class="line">0x00005555555558ce &lt;+165&gt;:   cmp    rsi,0x6</span><br><span class="line">0x00005555555558d2 &lt;+169&gt;:   jne    0x5555555558a6 &lt;phase_6+125&gt;</span><br></pre></td></tr></table></figure>



<p>这里出现了个node1 。通过后面反复的[rdx+0x8]，可以推测这是一个链表</p>
<p>并且节点结构应该是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> padding;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span> ;</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以从内存里面验证这个观点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/100wx 0x555555559210</span><br><span class="line">0x555555559210 &lt;node1&gt;: 0x000001c1      0x00000001      0x55559220      0x00005555</span><br><span class="line">0x555555559220 &lt;node2&gt;: 0x0000023f      0x00000002      0x55559230      0x00005555</span><br><span class="line">0x555555559230 &lt;node3&gt;: 0x000003b6      0x00000003      0x55559240      0x00005555</span><br><span class="line">0x555555559240 &lt;node4&gt;: 0x00000379      0x00000004      0x55559250      0x00005555</span><br><span class="line">0x555555559250 &lt;node5&gt;: 0x0000007d      0x00000005      0x55559110      0x00005555</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/4wx 0x555555559110</span><br><span class="line">0x555555559110 &lt;node6&gt;: 0x0000006b      0x00000006      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>



<p>可以发现题目还非常好心的把padding标上的标号。但其实我并没有在phase中看到有这个操作。</p>
<p>这里具体做的事情，就是按照标号，取出链表节点.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555558a1 &lt;+120&gt;:   mov    esi,0x0</span><br><span class="line">0x00005555555558a6 &lt;+125&gt;:   mov    ecx,DWORD PTR [rsp+rsi*4]</span><br><span class="line">0x00005555555558a9 &lt;+128&gt;:   mov    eax,0x1</span><br><span class="line">0x00005555555558ae &lt;+133&gt;:   lea    rdx,[rip+0x395b]        # 0x555555559210 &lt;node1&gt;</span><br><span class="line">0x00005555555558b5 &lt;+140&gt;:   cmp    ecx,0x1</span><br><span class="line">0x00005555555558b8 &lt;+143&gt;:   jle    0x5555555558c5 &lt;phase_6+156&gt;</span><br><span class="line">0x00005555555558ba &lt;+145&gt;:   mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">0x00005555555558be &lt;+149&gt;:   add    eax,0x1</span><br><span class="line">0x00005555555558c1 &lt;+152&gt;:   cmp    eax,ecx</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后再把对应指针存储到rsp+0x20开始的数组</p>
<blockquote>
<p>6*4 &#x3D; 0x18 为什么要空 0x08?  这通常是为了进行对齐</p>
</blockquote>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555558d4 &lt;+171&gt;:   mov    rbx,QWORD PTR [rsp+0x20]</span><br><span class="line">0x00005555555558d9 &lt;+176&gt;:   mov    rax,QWORD PTR [rsp+0x28]</span><br><span class="line">0x00005555555558de &lt;+181&gt;:   mov    QWORD PTR [rbx+0x8],rax</span><br><span class="line">0x00005555555558e2 &lt;+185&gt;:   mov    rdx,QWORD PTR [rsp+0x30]</span><br><span class="line">0x00005555555558e7 &lt;+190&gt;:   mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">0x00005555555558eb &lt;+194&gt;:   mov    rax,QWORD PTR [rsp+0x38]</span><br><span class="line">0x00005555555558f0 &lt;+199&gt;:   mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">0x00005555555558f4 &lt;+203&gt;:   mov    rdx,QWORD PTR [rsp+0x40]</span><br><span class="line">0x00005555555558f9 &lt;+208&gt;:   mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">0x00005555555558fd &lt;+212&gt;:   mov    rax,QWORD PTR [rsp+0x48]</span><br><span class="line">0x0000555555555902 &lt;+217&gt;:   mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">0x0000555555555906 &lt;+221&gt;:   mov    QWORD PTR [rax+0x8],0x0</span><br></pre></td></tr></table></figure>



<p>最轻松的一部分，可以看出就是按照数组顺序，重新连接了单链表。</p>
<h4 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000055555555590e &lt;+229&gt;:   mov    ebp,0x5</span><br><span class="line">0x0000555555555913 &lt;+234&gt;:   jmp    0x55555555591e &lt;phase_6+245&gt;</span><br><span class="line">0x0000555555555915 &lt;+236&gt;:   mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">0x0000555555555919 &lt;+240&gt;:   sub    ebp,0x1</span><br><span class="line">0x000055555555591c &lt;+243&gt;:   je     0x55555555592f &lt;phase_6+262&gt;</span><br><span class="line">0x000055555555591e &lt;+245&gt;:   mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">0x0000555555555922 &lt;+249&gt;:   mov    eax,DWORD PTR [rax]</span><br><span class="line">0x0000555555555924 &lt;+251&gt;:   cmp    DWORD PTR [rbx],eax</span><br><span class="line">0x0000555555555926 &lt;+253&gt;:   jle    0x555555555915 &lt;phase_6+236&gt;</span><br><span class="line">0x0000555555555928 &lt;+255&gt;:   call   0x555555555bb3 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555592d &lt;+260&gt;:   jmp    0x555555555915 &lt;phase_6+236&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个部分也不难，ebp是for里面的i  (i&#x3D;5 ;i&gt;0;i–)，rbx是上一个部分已经存储的第一个节点指针，可以当成head</p>
<p>那么就是进行5次比较，</p>
<p>判断当前节点数据是否小于等于下一节点数据。</p>
<p>综上，四个部分的结果就是按照标号，重新排列了链表，要求最后的链表是递增的。</p>
<h3 id="outcome-5"><a href="#outcome-5" class="headerlink" title="outcome"></a>outcome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">6 5 1 2 4 3</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure>



<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>按照实验要求，我需要使用argv[1]传入输入的内容</p>
<p>建立一个文本整合上述输入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ./bomb solution_24300240142_彭宇.txt</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br><span class="line">❯ cat solution_24300240142_彭宇.txt</span><br><span class="line">For NASA, space is still a high priority.</span><br><span class="line">0 1 3 6 10 15</span><br><span class="line">5 -204</span><br><span class="line">14 7</span><br><span class="line">AKLMNO</span><br><span class="line">6 5 1 2 4 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">v我50.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/QRpay/WechatPay.jpg"><img loading="lazy" src="/QRpay/WechatPay.jpg" alt="微信" title="微信"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>py</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://juryorca.github.io/2025/10/16/bomblab/" title="Bomb_LAB实验报告">http://juryorca.github.io/2025/10/16/bomblab/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2025/10/21/%E5%BC%B7%E7%B6%B2%E6%9D%AF%E5%BE%A9%E7%9B%A4/" rel="prev" title="強網杯復盤"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">強網杯復盤</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2025/09/30/kernel-pwn%E6%B5%81%E7%A8%8B/" rel="next" title="kernel_pwn流程"><span class="post-nav-text">kernel_pwn流程</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> py</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>