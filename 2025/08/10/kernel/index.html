<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="py"><meta name="copyright" content="py"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>kernel | 我是py</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon/favicon.ico"><link rel="mask-icon" href="/favicon/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"juryorca.github.io","root":"/","title":"宇宙终极无敌猫猫虫大王","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="基础内核内核本质和用户进程一样，但是内核拥有完全的硬件访问能力 ， 用户态代码只有部分硬件访问能力 分级保护环 Rings 将计算机资源划分成不同权限的模型从最高级0级到最低级 Intelcpu权限分四个等级 现代操作系统中只会使用ring0和ring3用户态:ring3+用户进程运行环境内核态:ring0+内核代码运行环境 状态切换不同级切换途径:  中断(interrupt) 和 异常(exc">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel">
<meta property="og:url" content="http://juryorca.github.io/2025/08/10/kernel/index.html">
<meta property="og:site_name" content="我是py">
<meta property="og:description" content="基础内核内核本质和用户进程一样，但是内核拥有完全的硬件访问能力 ， 用户态代码只有部分硬件访问能力 分级保护环 Rings 将计算机资源划分成不同权限的模型从最高级0级到最低级 Intelcpu权限分四个等级 现代操作系统中只会使用ring0和ring3用户态:ring3+用户进程运行环境内核态:ring0+内核代码运行环境 状态切换不同级切换途径:  中断(interrupt) 和 异常(exc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://juryorca.github.io/2025/08/10/kernel/task_struct.png">
<meta property="og:image" content="http://juryorca.github.io/2025/08/10/kernel/page_table.png">
<meta property="og:image" content="http://juryorca.github.io/2025/08/10/kernel/memory_locate.png">
<meta property="article:published_time" content="2025-08-10T05:45:10.000Z">
<meta property="article:modified_time" content="2025-11-22T06:32:30.210Z">
<meta property="article:author" content="py">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://juryorca.github.io/2025/08/10/kernel/task_struct.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="py"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="py"></a><div class="site-author-name"><a href="/about/">py</a></div><span class="site-name">我是py</span><sub class="site-subtitle">我是py</sub><div class="site-description">无敌奶龙大王cfy & cgxy和无敌疾旋鼬大王dcm</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Juryorca" title="GitHub" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/i-wanna-41-50" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="都是大佬stO" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">1.1.</span> <span class="toc-text">内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E7%8E%AF-Rings-%E5%B0%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B5%84%E6%BA%90%E5%88%92%E5%88%86%E6%88%90%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">分级保护环 Rings 将计算机资源划分成不同权限的模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">状态切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">虚拟内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">进程权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">进程描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E5%87%AD%E8%AF%81-credential"><span class="toc-number">1.6.2.</span> <span class="toc-text">进程权限凭证 credential</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%94%B9%E5%8F%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">权限改变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loadable-Kernel-Modules-LKMs"><span class="toc-number">1.7.</span> <span class="toc-text">Loadable Kernel Modules LKMs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BA%A4%E4%BA%92"><span class="toc-number">1.8.</span> <span class="toc-text">内核交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ioctl"><span class="toc-number">1.8.1.</span> <span class="toc-text">ioctl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">常用内核态函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mitigation"><span class="toc-number">1.10.</span> <span class="toc-text">Mitigation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E2%80%9C%E5%A0%86%E2%80%9D%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.11.</span> <span class="toc-text">内核“堆”保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardened-Usercopy"><span class="toc-number">1.11.1.</span> <span class="toc-text">Hardened Usercopy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardened-freelist"><span class="toc-number">1.11.2.</span> <span class="toc-text">Hardened freelist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random-freelist"><span class="toc-number">1.11.3.</span> <span class="toc-text">Random freelist</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CTF"><span class="toc-number">1.12.</span> <span class="toc-text">CTF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#how-to-switch-between-rings-normally-in-linux-amd64"><span class="toc-number">1.13.</span> <span class="toc-text">how to switch between rings normally in linux amd64?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioctl-1"><span class="toc-number">1.14.</span> <span class="toc-text">ioctl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-access"><span class="toc-number">1.15.</span> <span class="toc-text">data access</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#escape-seccomp"><span class="toc-number">1.16.</span> <span class="toc-text">escape seccomp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-management"><span class="toc-number">1.17.</span> <span class="toc-text">memory management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process-memory"><span class="toc-number">1.17.1.</span> <span class="toc-text">process memory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cheatsheet"><span class="toc-number">2.</span> <span class="toc-text">cheatsheet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#writing-userspace-shellcode"><span class="toc-number">2.1.</span> <span class="toc-text">writing userspace shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8pid%E6%9F%A5%E6%89%BE%E6%9C%AA%E8%A2%ABkill%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9F%90%E4%B8%AA%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">用pid查找未被kill的进程的某个虚拟地址对应的真实地址。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bslab%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">查看slab状态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useful-gadgets"><span class="toc-number">2.4.</span> <span class="toc-text">useful gadgets</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://Juryorca.github.io/2025/08/10/kernel/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="py"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="我是py"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">kernel</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2025-08-10 13:45:10" itemprop="dateCreated datePublished" datetime="2025-08-10T13:45:10+08:00">2025-08-10</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2025-11-22 14:32:30" itemprop="dateModified" datetime="2025-11-22T14:32:30+08:00">2025-11-22</time></div><div class="post-classify"><span class="post-tag"><a class="tag-item" href="/tags/pwn/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">pwn</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>内核本质和用户进程一样，但是内核拥有完全的硬件访问能力 ， 用户态代码只有部分硬件访问能力</p>
<h2 id="分级保护环-Rings-将计算机资源划分成不同权限的模型"><a href="#分级保护环-Rings-将计算机资源划分成不同权限的模型" class="headerlink" title="分级保护环 Rings 将计算机资源划分成不同权限的模型"></a>分级保护环 Rings 将计算机资源划分成不同权限的模型</h2><p>从最高级0级到最低级</p>
<p>Intelcpu权限分四个等级 现代操作系统中只会使用ring0和ring3<br>用户态:ring3+用户进程运行环境<br>内核态:ring0+内核代码运行环境</p>
<h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><p>不同级切换途径:</p>
<ul>
<li>中断(interrupt) 和 异常(exception) 收到中断&#x2F;异常时切换至ring0 </li>
<li>特权级指令 例如iret 或者 sysenter</li>
</ul>
<p>现代操作系统用syscall</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用。异常，外设中断等事件发生时进行切换</p>
<p>系统调用指令执行后 在内核态完成以下操作</p>
<ol>
<li>通过swapgs切换GS段寄存器  将GS寄存器的值和一个特定位置的值交换，保存GS值，该位置的值作为内核运行GS值使用</li>
<li>当前栈顶记录在CPU独占变量区域，将独占区域记录的内核栈顶放入rsp&#x2F;rsp</li>
<li>push保存各寄存器的值</li>
<li>判断是否为x32_abi</li>
<li>跳转到sys_call_table，执行系统调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> <span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure>

<p>退出时</p>
<ol>
<li>通过swapgs恢复GS值</li>
<li>通过sysretq或者iretq恢复到用户控件继续执行 ，如果用ireq还需要给出用户空间一些信息.</li>
</ol>
<h2 id="虚拟内存空间"><a href="#虚拟内存空间" class="headerlink" title="虚拟内存空间"></a>虚拟内存空间</h2><p>虚拟内存地址空间分为两块: user space 和 kernel space .<br>linux通常较高的分配给内核</p>
<h2 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h2><p>用户应用权限时kernel管理的</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>内核中用 task_struct表示进程。定义于内核源码include&#x2F;linux&#x2F;sched.h中<br><img src="/2025/08/10/kernel/task_struct.png" alt="task_struct.png" loading="lazy"></p>
<h3 id="进程权限凭证-credential"><a href="#进程权限凭证-credential" class="headerlink" title="进程权限凭证 credential"></a>进程权限凭证 credential</h3><p>结构体cred用于管理一个进程的权限 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *  task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *  upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task&#x27;s actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>   usage;</span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="comment">/* RCU deletion */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;            <span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>一个cred结构体记载进程中四种不同的用户ID<br>real UID :进程启动时用户ID<br>saved UID :进程最初的有效用户ID<br>effective UID:进程正在运行时所属的用户ID<br>UID for VFS ops : 创建文件时标识的用户ID</p>
<h3 id="权限改变"><a href="#权限改变" class="headerlink" title="权限改变"></a>权限改变</h3><p>改变cred结构体就能改变其执行权限</p>
<p>struct cred* prepare_kernel_cred(struct task_struct* daemon)<br>拷贝一个进程的cred 返回一个新的cred<br>int commit_creds(struct cred *new) 将新的cred应用到当前程序</p>
<h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules LKMs"></a>Loadable Kernel Modules LKMs</h2><p>linux采用宏内核架构 一切系统服务都需要由内核提供。缺乏可扩展性和可维护性。内核装载很多可能用到的服务 占据大量内存空间<br>内核空间的LKMs可以提供新的系统调用和其他服务 ,可以像积木一样被装载入内核&#x2F;从内核中卸载。</p>
<p>常见LKMs:</p>
<ul>
<li>启动程序<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
</ul>
</li>
<li>内核扩展模块</li>
</ul>
<p>LKMs文件格式和用户态可执行程序相同 可以用IDA分析<br>模块可以单独被编译 但是需要在运行时链接到内核作为内核的一部分</p>
<p>insmod: 将指定模块加载到内核<br>rmmodL: 卸载指定模块<br>lsmod: 列出已经加载的模块<br>modprobe: 添加或删除模块</p>
<p>大多数kernel漏洞出现在LKM中</p>
<h2 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h2><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><p>linux 定义了系统调用ioctl供进程和设备之间进行通信<br>第一个参数是打开设备返回的文件描述符，第二个参数是用户程序对设备的控制命令，后面是补充参数<br>ioctl 可以和设备驱动沟通 。</p>
<h2 id="常用内核态函数"><a href="#常用内核态函数" class="headerlink" title="常用内核态函数"></a>常用内核态函数</h2><p>printf() -&gt; printk() printk不一定会把内容显示到终端上，但一定在内核缓冲区。<br>memcpy() -&gt; copy_from_user()&#x2F;copy_to_user()<br>malloc() -&gt; kmalloc() 使用的是slab分配器<br>free -&gt; kfree()<br>kernel 记录了进程的权限 。<br>commit_creds(prepare_kernel_cred(&amp;init_task)) 可以设置root权限 这是最常用的提权手段<br>这些变量的地址可以在&#x2F;proc&#x2F;kallsyms 中查看 较老的内核版本是&#x2F;proc&#x2F;ksyms</p>
<h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Kernel保护机制<br>canary dep PIE RELRO </p>
<p>KASLR 内核的aslr</p>
<p>*FGKASLR 以函数粒度重新排布内核代码</p>
<p>STACK PROTECTOR  stack cookie 检测是否发生内核堆栈溢出<br>通常取自gs段寄存器某个固定偏移处的值</p>
<p>SMAP 管理模式访问保护<br>SMEP 管理模式执行保护 通常同时开启，组织内核空间直接访问&#x2F;执行用户空间的数据,防范ret2user攻击</p>
<p>可以用以下两种方式绕过:</p>
<ul>
<li>内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址 ret2dir</li>
<li>intel下系统根据CR4寄存器的第20位标识是否开启SMEP保护 若能够通过 kernelROP g改变CR4寄存器的值便能关闭SMEP 但是开启了KPTI的内核 用户地址空间无执行权限</li>
</ul>
<p>KPTI 内核页表隔离 内核空间和用户空间使用两组不同的页表集，对内核的内存管理产生了根本性的变化<br>这两张表上都有对用户内存空间的完整映射 但是用户页表中只映射了少量内核代码<br>主要用于修复Meltdown漏洞</p>
<h2 id="内核“堆”保护机制"><a href="#内核“堆”保护机制" class="headerlink" title="内核“堆”保护机制"></a>内核“堆”保护机制</h2><h3 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h3><p>主要检查拷贝过程中对内核空间中数据的读写是否会越界:<br>读取的数据长度是否超出源object范围<br>写入的数据长度是否超出目的object范围</p>
<p>用于copy_to_user() 与 copy_from_user() 等数据交换API。不适用于内核空间内的数据拷贝。</p>
<h3 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h3><p>开启保护之前 slub中的free object 的next指针直接存放next free object 地址 ，可以通过读取freelist泄露出内核线性映射区的地址<br>开启之后next存放当前free object  下一个free object  随机值 三者异或</p>
<p>至少要获取一和三才能篡改</p>
<h3 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h3><p>开启这个保护后 ，object之间的连接顺序是随机的，让攻击者无法预测下一个分配的object的地址</p>
<p>发生在slub allocator刚从buddy system 拿到新slub的时候 ，运行时freelist仍然遵循LIFO</p>
<p>进行分配时 会把内存上内容清零</p>
<p>CONFIG_SLAB_FREELIST_RANDOMIZATION</p>
<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>一般有三个文件 :</p>
<ol>
<li>boot.sh: 用于启动kernel的shell脚本。多用qemu</li>
<li>bzImage: compressed kernel binary</li>
<li>rootfs.cpio: 系统映像</li>
</ol>
<hr>
<h2 id="how-to-switch-between-rings-normally-in-linux-amd64"><a href="#how-to-switch-between-rings-normally-in-linux-amd64" class="headerlink" title="how to switch between rings normally in linux amd64?"></a>how to switch between rings normally in linux amd64?</h2><p>kernel 在启动时 ，会把MSR_LSTAR定义到kernel内部一个入口点，执行syscall之类的切换指令，就会把pc设置到这个入口点。返回地址会保存到rcx! 返回时 设置到Ring3 然后跳转到rcx!</p>
<p>&#x2F;proc&#x2F;kallsyms 可以看到内核的调试符号  </p>
<h2 id="ioctl-1"><a href="#ioctl-1" class="headerlink" title="ioctl"></a>ioctl</h2><p>int fd &#x3D; open(“&#x2F;dev&#x2F;pwn-college”,0)</p>
<p>ioctl(fd,COMMAND_CODE,&amp;custom_data_structrue)</p>
<h2 id="data-access"><a href="#data-access" class="headerlink" title="data access"></a>data access</h2><p>copy_to_user(userspace_address , kernel_address ,length)</p>
<p>copy_from_user( kernel_address ,userspace_address,length)</p>
<h2 id="escape-seccomp"><a href="#escape-seccomp" class="headerlink" title="escape seccomp"></a>escape seccomp</h2><p>内核通常会保持将gs寄存器指向 current_task_struct</p>
<h2 id="memory-management"><a href="#memory-management" class="headerlink" title="memory management"></a>memory management</h2><h3 id="process-memory"><a href="#process-memory" class="headerlink" title="process memory"></a>process memory</h3><ul>
<li><p>binary</p>
</li>
<li><p>libraries</p>
</li>
<li><p>heap</p>
</li>
<li><p>stack</p>
</li>
<li><p>mapped memory</p>
</li>
<li><p>helper regions</p>
</li>
<li><p>kernel code</p>
</li>
</ul>
<p>一个 virtual memory 对应一个进程</p>
<p>physical memory 在整个操作系统共享</p>
<p><img src="/2025/08/10/kernel/page_table.png" alt="page_table.png" loading="lazy"></p>
<p><img src="/2025/08/10/kernel/memory_locate.png" alt="memory_locate.png" loading="lazy"></p>
<p>cr3存储pml4 的位置 ，每个进程有独立的cr3</p>
<hr>
<h1 id="cheatsheet"><a href="#cheatsheet" class="headerlink" title="cheatsheet"></a>cheatsheet</h1><h2 id="writing-userspace-shellcode"><a href="#writing-userspace-shellcode" class="headerlink" title="writing userspace shellcode"></a>writing userspace shellcode</h2><p>关键: 使用kernel API</p>
<p>需要在kernel内部 call 这些kernel API , 使用call指令。</p>
<p>commit_creds  可以接受prepare_kernel_cred ,也可以接受init_cred的地址 ，甚至可以接受一个伪造的cred。</p>
<p>run_cmd    不会有回显，因为是在内核模块内部运行，通常用&#x2F;bin&#x2F;chmod a+rwx &#x2F;flag</p>
<h2 id="用pid查找未被kill的进程的某个虚拟地址对应的真实地址。"><a href="#用pid查找未被kill的进程的某个虚拟地址对应的真实地址。" class="headerlink" title="用pid查找未被kill的进程的某个虚拟地址对应的真实地址。"></a>用pid查找未被kill的进程的某个虚拟地址对应的真实地址。</h2><p>流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kpid</span> =</span> find_get_pid(pid);</span><br><span class="line">task = get_pid_task (kpid,PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> v_address = <span class="number">0x404040</span>;</span><br><span class="line"><span class="type">pgd_t</span> * pgde;</span><br><span class="line"><span class="type">p4d_t</span> * p4de;</span><br><span class="line"><span class="type">pud_t</span> * pude;</span><br><span class="line"><span class="type">pmd_t</span> * pmde;</span><br><span class="line"><span class="type">pte_t</span> * pte;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> task-&gt;mm;</span><br><span class="line">pgde = pgd_offset(mm,v_address);  </span><br><span class="line">p4de = p4d_offset(pgde,v_address);</span><br><span class="line">pude = pud_offset(p4de,v_address);</span><br><span class="line">pmde = pmd_offset(pude,v_address);</span><br><span class="line">pte = pte_offset_kernel(pmde,v_address);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> page_addr = pte_val(*pte) &amp; PAGE_MASK;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> page_offset = v_address &amp; ~PAGE_MASK;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> phy_addr = page_addr | page_offset;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> PT_addr = pte_page(*pte);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vptr = kmap(PT_addr);</span><br><span class="line"><span class="type">char</span> *flag = (<span class="type">char</span> *)(vptr + page_offset);</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;flag : %s\n&quot;</span>,flag);</span><br><span class="line">kunmap(page_addr);</span><br></pre></td></tr></table></figure>



<p>跟踪子进程的话 可以用current -&gt; pid 获取当前进程pid  然后 pid+1 跟踪子进程。</p>
<p>编写shellcode的话，比较好的方法是搞成内核模块，然后用gdb获取各种地址。</p>
<h2 id="查看slab状态方法"><a href="#查看slab状态方法" class="headerlink" title="查看slab状态方法"></a>查看slab状态方法</h2><p>linux功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/slabinfo</span><br></pre></td></tr></table></figure>



<p>debugger</p>
<p><code>slab list</code></p>
<p><code>slab info &lt;cache_name&gt;</code></p>
<p><code>slab contains &lt;addr_1&gt; &lt;addr_2&gt;</code></p>
<p>sysfs</p>
<p><code>/sys/kernel/slab/&lt;cache_name&gt;/cpu_partial</code></p>
<p><code>/sys/kernel/slab/&lt;cache_name&gt;/objs_per_slab</code></p>
<p><code>/sys/kernel/slab/&lt;cache_name&gt;/min_partial</code></p>
<h2 id="useful-gadgets"><a href="#useful-gadgets" class="headerlink" title="useful gadgets"></a>useful gadgets</h2><p>work_for_cpu_fn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rbx</span><br><span class="line">mov rbx,rdi</span><br><span class="line">mov rdi,QWORD PTR [rdi+0x28]</span><br><span class="line">mov rax,QWORD PTR [rbx+0x20]</span><br><span class="line">call ???????&lt;__x86_indirect_thunk_array&gt;</span><br><span class="line">mov QWROD PTR [rbx+0x30],rax</span><br><span class="line">pop rbx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>可能用法 : rax搞成commit_creds rdi搞成&amp;init_cred 然后一把梭。</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">v我50.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/QRpay/WechatPay.jpg"><img loading="lazy" src="/QRpay/WechatPay.jpg" alt="微信" title="微信"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>py</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://juryorca.github.io/2025/08/10/kernel/" title="kernel">http://juryorca.github.io/2025/08/10/kernel/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2025/08/16/sekai-ctf/" rel="prev" title="sekai_ctf"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">sekai_ctf</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2025/08/09/Race-condition/" rel="next" title="Race_condition"><span class="post-nav-text">Race_condition</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> py</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>